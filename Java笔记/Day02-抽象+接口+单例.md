#### final

- 特点：
  - 修饰类：不能被继承
  - 修饰方法：不能被重写
  - 修饰变量：不能被再次赋值
- 注意点：
  - 如果修饰的是基本数据类型，则变量存储的数据值不能发生改变；如果修饰的是引用数据类型，则变量存储的地址值不能发生改变
  - 修饰局部变量时可以先定义后赋值，修饰成员变量时必须定义时完成赋值或在构造方法中赋值
  - 模板方法建议进行final修饰，防止之类重写，这样更安全、专业



#### 抽象方法

- 格式：`修饰符 abstract 返回值类型 方法名（参数列表）；`
- 注意点：**抽象方法都不可以被private、static、final修饰**，因为被其修饰的方法不能被重写



#### 抽象类

- 当父类知道子类一定要完成某些行为，但是每个子类该行为的实现又不同，于是该父类就把该行为定义成抽象方法的形式，具体实现交给子类去完成。此时这个类就可以声明成抽象类
- 格式：`权限修饰符 abstract class 类名{ ... }`

- 与普通类的区别：
  - 有得：得到定义抽象方法的能力
  - 有失：失去创建对象的能力
- final与abstract是互斥关系



#### 接口

- 格式：`权限修饰符 interface 接口名{ ... }`

- 注意点：
  - JDK7及以前，接口中只能定义常量和抽象方法
    - 常量：默认是`public static final`修饰，可以任意省略不写
    - 抽象方法：默认是`public abstract`修饰，可以任意省略不写
  - JDK8之后，接口中新增默认方法和静态方法两种非抽象方法
    - 默认方法：`public default 返回值类型 方法名（参数列表）{ ... }`
      - 方法必须用<u>default</u>修饰
      - 接口不能创建对象，因此只能由<u>创建接口的实现类对象</u>来调用
    - 静态方法：`public static 返回值类型 方法名（参数列表）{ ... }`
      - 方法使用<u>static</u>修饰
      - 用<u>接口名</u>调用
  - JDK9之后，接口中新增私有方法非抽象方法
    - 私有方法：
      - 使用private修饰，包含私有成员方法和私有静态方法
      - 私有方法只能在接口内调用
  - **接口的权限修饰符只能是public或缺省**
  - **接口中没有构造方法，所以接口不能创建对象**
- 接口的用法：
  - 接口与类是实现关系，接口是用来被类实现的，实现接口的类称为实现类，必须重写接口的所有抽象方法，否则这个类需要定义成抽象类
  - 一个类可以实现多个接口
    - 格式：`权限修饰符 class 类名 implements 接口1，接口2{ ... }`
  - 接口和接口之间是多继承关系，用于整合多个接口为一个，便于子类实现
    - 格式：`权限修饰符 interface 接口名 extends 接口1，接口2{ ... }`

- 接口的注意事项
  1. 接口不能创建对象
  2. 一个类实现多个接口，多个接口中有同样的静态方法不冲突
  3. 一个类继承了父类，同时又实现了接口，父类中和接口中有同名方法，默认用父类的
  4. 一个类实现了多个接口，多个接口中存在同名的默认方法，不冲突，在这个类中重写该方法即可
  5. 一个接口继承多个接口，的前提是多个接口之间不存在规范冲突



#### 抽象类和接口的区别

- 语法区别
  - 接口和抽象类都可以定义抽象方法
  - 接口和抽象类都不能创建对象
  - 抽象类可以定义成员变量，构造方法等其他成员
  - JDK7之前，接口中的只能定义常量和抽象方法，接口不能有构造方法
  - JDK8之后，接口中可以有默认方法，静态方法，私有方法等非抽象方法
- 作用区别
  - 抽象类可以被子类继承，而且只能单继承
  - 接口可以被子类实现，而且支持多实现；接口也可以被其他接口继承，而且是多继承
- 设计思想
  - 抽象类是对子类共同特征的抽取，可以将多个子类中相同的属性和行为抽取到父类中，某些实现细节定义成抽象方法，子类可以继承和重写，以达到简化代码，复用功能的目的
  - 接口是对功能的统一和约束，实现接口的目的是为了扩展类的功能



#### 单例

- 饿汉式单例和懒汉式单例的优缺点：
  - 代码执行效率：饿汉式效率更高，懒汉式单例首次调用时需要等待对象创建，每次调用都有判断对象是否存在
  - 内存空间占用：懒汉式单例更节省内存，对象没有提前创建，不会提前占用堆空间；饿汉式在类加载时就创建好了，相对占用内存
  - 实际开发中，效率更重要，推荐使用饿汉式单例！（饿汉式效率高，代码实现简单）

- 饿汉单例

```java
//把Singleton类设计成单例类，只能创建一个对象
/*
    饿汉式单例：
      1.私有构造方法
      2.提前创建好一个对象，让外界去使用
      3.提供一个获取对象的静态方法

   单例模式应用场景：一个系统中，某些对象只能有一个，可以使用单例模式设计
       一个系统中的超级管理员只能有一个，可以使用单例模式设计
 */
public class Singleton {

    //1.私有构造方法，外界无法使用构造方法创建对象
    private Singleton(){

    }

    //2.提前创建好一个对象，让外界去使用
    //private不让外界直接访问
    //static表示对象只有一个
    //final表示single对象不能重复new，地址是不可变的
    private static final Singleton single = new Singleton();

    //3.提供一个获取对象的静态方法
    public static Singleton getInstance(){
        return single;
    }
}
```



- 懒汉单列

```java
//系统管理员，保证这个类只能创建一个对象

/*
    懒汉式单例
        1.私有构造方法
        2.提供一个对象，让外界去使用（不会提前创建）
        3.提供一个静态方法，用于获取对象，在方法中去创建对象
 */

public class SystemUser {
    //1.私有构造方法
    private SystemUser(){

    }

    //2.提供一个对象，让外界去使用（不会提前创建）
    private static SystemUser user = null;

    //3.提供一个静态方法，用于获取对象，在方法中去创建对象
    //在多线程环境下，会有并发安全问题，可以通过加锁解决线程安全问题
    public static SystemUser getInstance(){
        //如果首次使用，创建出对象
        if(user==null){
            user = new SystemUser();
        }

        return user;
    }
}
```

